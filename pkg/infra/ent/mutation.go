// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/m-mizutani/octovy/pkg/domain/types"
	"github.com/m-mizutani/octovy/pkg/infra/ent/authstatecache"
	"github.com/m-mizutani/octovy/pkg/infra/ent/packagerecord"
	"github.com/m-mizutani/octovy/pkg/infra/ent/predicate"
	"github.com/m-mizutani/octovy/pkg/infra/ent/repository"
	"github.com/m-mizutani/octovy/pkg/infra/ent/scan"
	"github.com/m-mizutani/octovy/pkg/infra/ent/session"
	"github.com/m-mizutani/octovy/pkg/infra/ent/user"
	"github.com/m-mizutani/octovy/pkg/infra/ent/vulnerability"
	"github.com/m-mizutani/octovy/pkg/infra/ent/vulnstatus"
	"github.com/m-mizutani/octovy/pkg/infra/ent/vulnstatusindex"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthStateCache  = "AuthStateCache"
	TypePackageRecord   = "PackageRecord"
	TypeRepository      = "Repository"
	TypeScan            = "Scan"
	TypeSession         = "Session"
	TypeUser            = "User"
	TypeVulnStatus      = "VulnStatus"
	TypeVulnStatusIndex = "VulnStatusIndex"
	TypeVulnerability   = "Vulnerability"
)

// AuthStateCacheMutation represents an operation that mutates the AuthStateCache nodes in the graph.
type AuthStateCacheMutation struct {
	config
	op            Op
	typ           string
	id            *string
	expires_at    *int64
	addexpires_at *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthStateCache, error)
	predicates    []predicate.AuthStateCache
}

var _ ent.Mutation = (*AuthStateCacheMutation)(nil)

// authstatecacheOption allows management of the mutation configuration using functional options.
type authstatecacheOption func(*AuthStateCacheMutation)

// newAuthStateCacheMutation creates new mutation for the AuthStateCache entity.
func newAuthStateCacheMutation(c config, op Op, opts ...authstatecacheOption) *AuthStateCacheMutation {
	m := &AuthStateCacheMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthStateCache,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthStateCacheID sets the ID field of the mutation.
func withAuthStateCacheID(id string) authstatecacheOption {
	return func(m *AuthStateCacheMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthStateCache
		)
		m.oldValue = func(ctx context.Context) (*AuthStateCache, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthStateCache.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthStateCache sets the old AuthStateCache of the mutation.
func withAuthStateCache(node *AuthStateCache) authstatecacheOption {
	return func(m *AuthStateCacheMutation) {
		m.oldValue = func(context.Context) (*AuthStateCache, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthStateCacheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthStateCacheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthStateCache entities.
func (m *AuthStateCacheMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthStateCacheMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetExpiresAt sets the "expires_at" field.
func (m *AuthStateCacheMutation) SetExpiresAt(i int64) {
	m.expires_at = &i
	m.addexpires_at = nil
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AuthStateCacheMutation) ExpiresAt() (r int64, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AuthStateCache entity.
// If the AuthStateCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthStateCacheMutation) OldExpiresAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// AddExpiresAt adds i to the "expires_at" field.
func (m *AuthStateCacheMutation) AddExpiresAt(i int64) {
	if m.addexpires_at != nil {
		*m.addexpires_at += i
	} else {
		m.addexpires_at = &i
	}
}

// AddedExpiresAt returns the value that was added to the "expires_at" field in this mutation.
func (m *AuthStateCacheMutation) AddedExpiresAt() (r int64, exists bool) {
	v := m.addexpires_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AuthStateCacheMutation) ResetExpiresAt() {
	m.expires_at = nil
	m.addexpires_at = nil
}

// Where appends a list predicates to the AuthStateCacheMutation builder.
func (m *AuthStateCacheMutation) Where(ps ...predicate.AuthStateCache) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthStateCacheMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthStateCache).
func (m *AuthStateCacheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthStateCacheMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.expires_at != nil {
		fields = append(fields, authstatecache.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthStateCacheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authstatecache.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthStateCacheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authstatecache.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthStateCache field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthStateCacheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authstatecache.FieldExpiresAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthStateCache field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthStateCacheMutation) AddedFields() []string {
	var fields []string
	if m.addexpires_at != nil {
		fields = append(fields, authstatecache.FieldExpiresAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthStateCacheMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case authstatecache.FieldExpiresAt:
		return m.AddedExpiresAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthStateCacheMutation) AddField(name string, value ent.Value) error {
	switch name {
	case authstatecache.FieldExpiresAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthStateCache numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthStateCacheMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthStateCacheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthStateCacheMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthStateCache nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthStateCacheMutation) ResetField(name string) error {
	switch name {
	case authstatecache.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown AuthStateCache field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthStateCacheMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthStateCacheMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthStateCacheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthStateCacheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthStateCacheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthStateCacheMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthStateCacheMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthStateCache unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthStateCacheMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthStateCache edge %s", name)
}

// PackageRecordMutation represents an operation that mutates the PackageRecord nodes in the graph.
type PackageRecordMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_type                  *string
	source                 *string
	name                   *string
	version                *string
	vuln_ids               *[]string
	clearedFields          map[string]struct{}
	scan                   map[string]struct{}
	removedscan            map[string]struct{}
	clearedscan            bool
	vulnerabilities        map[string]struct{}
	removedvulnerabilities map[string]struct{}
	clearedvulnerabilities bool
	done                   bool
	oldValue               func(context.Context) (*PackageRecord, error)
	predicates             []predicate.PackageRecord
}

var _ ent.Mutation = (*PackageRecordMutation)(nil)

// packagerecordOption allows management of the mutation configuration using functional options.
type packagerecordOption func(*PackageRecordMutation)

// newPackageRecordMutation creates new mutation for the PackageRecord entity.
func newPackageRecordMutation(c config, op Op, opts ...packagerecordOption) *PackageRecordMutation {
	m := &PackageRecordMutation{
		config:        c,
		op:            op,
		typ:           TypePackageRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageRecordID sets the ID field of the mutation.
func withPackageRecordID(id int) packagerecordOption {
	return func(m *PackageRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageRecord
		)
		m.oldValue = func(ctx context.Context) (*PackageRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageRecord sets the old PackageRecord of the mutation.
func withPackageRecord(node *PackageRecord) packagerecordOption {
	return func(m *PackageRecordMutation) {
		m.oldValue = func(context.Context) (*PackageRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "type" field.
func (m *PackageRecordMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PackageRecordMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PackageRecord entity.
// If the PackageRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageRecordMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PackageRecordMutation) ResetType() {
	m._type = nil
}

// SetSource sets the "source" field.
func (m *PackageRecordMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *PackageRecordMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the PackageRecord entity.
// If the PackageRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageRecordMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *PackageRecordMutation) ResetSource() {
	m.source = nil
}

// SetName sets the "name" field.
func (m *PackageRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PackageRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PackageRecord entity.
// If the PackageRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PackageRecordMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PackageRecordMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PackageRecordMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PackageRecord entity.
// If the PackageRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageRecordMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PackageRecordMutation) ResetVersion() {
	m.version = nil
}

// SetVulnIds sets the "vuln_ids" field.
func (m *PackageRecordMutation) SetVulnIds(s []string) {
	m.vuln_ids = &s
}

// VulnIds returns the value of the "vuln_ids" field in the mutation.
func (m *PackageRecordMutation) VulnIds() (r []string, exists bool) {
	v := m.vuln_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnIds returns the old "vuln_ids" field's value of the PackageRecord entity.
// If the PackageRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageRecordMutation) OldVulnIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVulnIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVulnIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnIds: %w", err)
	}
	return oldValue.VulnIds, nil
}

// ResetVulnIds resets all changes to the "vuln_ids" field.
func (m *PackageRecordMutation) ResetVulnIds() {
	m.vuln_ids = nil
}

// AddScanIDs adds the "scan" edge to the Scan entity by ids.
func (m *PackageRecordMutation) AddScanIDs(ids ...string) {
	if m.scan == nil {
		m.scan = make(map[string]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the Scan entity.
func (m *PackageRecordMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the Scan entity was cleared.
func (m *PackageRecordMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the Scan entity by IDs.
func (m *PackageRecordMutation) RemoveScanIDs(ids ...string) {
	if m.removedscan == nil {
		m.removedscan = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the Scan entity.
func (m *PackageRecordMutation) RemovedScanIDs() (ids []string) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *PackageRecordMutation) ScanIDs() (ids []string) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *PackageRecordMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the Vulnerability entity by ids.
func (m *PackageRecordMutation) AddVulnerabilityIDs(ids ...string) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[string]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the Vulnerability entity.
func (m *PackageRecordMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the Vulnerability entity was cleared.
func (m *PackageRecordMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the Vulnerability entity by IDs.
func (m *PackageRecordMutation) RemoveVulnerabilityIDs(ids ...string) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the Vulnerability entity.
func (m *PackageRecordMutation) RemovedVulnerabilitiesIDs() (ids []string) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *PackageRecordMutation) VulnerabilitiesIDs() (ids []string) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *PackageRecordMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// Where appends a list predicates to the PackageRecordMutation builder.
func (m *PackageRecordMutation) Where(ps ...predicate.PackageRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PackageRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PackageRecord).
func (m *PackageRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageRecordMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, packagerecord.FieldType)
	}
	if m.source != nil {
		fields = append(fields, packagerecord.FieldSource)
	}
	if m.name != nil {
		fields = append(fields, packagerecord.FieldName)
	}
	if m.version != nil {
		fields = append(fields, packagerecord.FieldVersion)
	}
	if m.vuln_ids != nil {
		fields = append(fields, packagerecord.FieldVulnIds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagerecord.FieldType:
		return m.GetType()
	case packagerecord.FieldSource:
		return m.Source()
	case packagerecord.FieldName:
		return m.Name()
	case packagerecord.FieldVersion:
		return m.Version()
	case packagerecord.FieldVulnIds:
		return m.VulnIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagerecord.FieldType:
		return m.OldType(ctx)
	case packagerecord.FieldSource:
		return m.OldSource(ctx)
	case packagerecord.FieldName:
		return m.OldName(ctx)
	case packagerecord.FieldVersion:
		return m.OldVersion(ctx)
	case packagerecord.FieldVulnIds:
		return m.OldVulnIds(ctx)
	}
	return nil, fmt.Errorf("unknown PackageRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagerecord.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case packagerecord.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case packagerecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case packagerecord.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case packagerecord.FieldVulnIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnIds(v)
		return nil
	}
	return fmt.Errorf("unknown PackageRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageRecordMutation) ResetField(name string) error {
	switch name {
	case packagerecord.FieldType:
		m.ResetType()
		return nil
	case packagerecord.FieldSource:
		m.ResetSource()
		return nil
	case packagerecord.FieldName:
		m.ResetName()
		return nil
	case packagerecord.FieldVersion:
		m.ResetVersion()
		return nil
	case packagerecord.FieldVulnIds:
		m.ResetVulnIds()
		return nil
	}
	return fmt.Errorf("unknown PackageRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.scan != nil {
		edges = append(edges, packagerecord.EdgeScan)
	}
	if m.vulnerabilities != nil {
		edges = append(edges, packagerecord.EdgeVulnerabilities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagerecord.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	case packagerecord.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedscan != nil {
		edges = append(edges, packagerecord.EdgeScan)
	}
	if m.removedvulnerabilities != nil {
		edges = append(edges, packagerecord.EdgeVulnerabilities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagerecord.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	case packagerecord.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedscan {
		edges = append(edges, packagerecord.EdgeScan)
	}
	if m.clearedvulnerabilities {
		edges = append(edges, packagerecord.EdgeVulnerabilities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case packagerecord.EdgeScan:
		return m.clearedscan
	case packagerecord.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageRecordMutation) ResetEdge(name string) error {
	switch name {
	case packagerecord.EdgeScan:
		m.ResetScan()
		return nil
	case packagerecord.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	}
	return fmt.Errorf("unknown PackageRecord edge %s", name)
}

// RepositoryMutation represents an operation that mutates the Repository nodes in the graph.
type RepositoryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	owner          *string
	name           *string
	install_id     *int64
	addinstall_id  *int64
	url            *string
	avatar_url     *string
	default_branch *string
	clearedFields  map[string]struct{}
	scan           map[string]struct{}
	removedscan    map[string]struct{}
	clearedscan    bool
	main           map[string]struct{}
	removedmain    map[string]struct{}
	clearedmain    bool
	latest         *string
	clearedlatest  bool
	status         map[string]struct{}
	removedstatus  map[string]struct{}
	clearedstatus  bool
	done           bool
	oldValue       func(context.Context) (*Repository, error)
	predicates     []predicate.Repository
}

var _ ent.Mutation = (*RepositoryMutation)(nil)

// repositoryOption allows management of the mutation configuration using functional options.
type repositoryOption func(*RepositoryMutation)

// newRepositoryMutation creates new mutation for the Repository entity.
func newRepositoryMutation(c config, op Op, opts ...repositoryOption) *RepositoryMutation {
	m := &RepositoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRepository,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryID sets the ID field of the mutation.
func withRepositoryID(id int) repositoryOption {
	return func(m *RepositoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Repository
		)
		m.oldValue = func(ctx context.Context) (*Repository, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repository.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepository sets the old Repository of the mutation.
func withRepository(node *Repository) repositoryOption {
	return func(m *RepositoryMutation) {
		m.oldValue = func(context.Context) (*Repository, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOwner sets the "owner" field.
func (m *RepositoryMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *RepositoryMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *RepositoryMutation) ResetOwner() {
	m.owner = nil
}

// SetName sets the "name" field.
func (m *RepositoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RepositoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RepositoryMutation) ResetName() {
	m.name = nil
}

// SetInstallID sets the "install_id" field.
func (m *RepositoryMutation) SetInstallID(i int64) {
	m.install_id = &i
	m.addinstall_id = nil
}

// InstallID returns the value of the "install_id" field in the mutation.
func (m *RepositoryMutation) InstallID() (r int64, exists bool) {
	v := m.install_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallID returns the old "install_id" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldInstallID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInstallID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInstallID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallID: %w", err)
	}
	return oldValue.InstallID, nil
}

// AddInstallID adds i to the "install_id" field.
func (m *RepositoryMutation) AddInstallID(i int64) {
	if m.addinstall_id != nil {
		*m.addinstall_id += i
	} else {
		m.addinstall_id = &i
	}
}

// AddedInstallID returns the value that was added to the "install_id" field in this mutation.
func (m *RepositoryMutation) AddedInstallID() (r int64, exists bool) {
	v := m.addinstall_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearInstallID clears the value of the "install_id" field.
func (m *RepositoryMutation) ClearInstallID() {
	m.install_id = nil
	m.addinstall_id = nil
	m.clearedFields[repository.FieldInstallID] = struct{}{}
}

// InstallIDCleared returns if the "install_id" field was cleared in this mutation.
func (m *RepositoryMutation) InstallIDCleared() bool {
	_, ok := m.clearedFields[repository.FieldInstallID]
	return ok
}

// ResetInstallID resets all changes to the "install_id" field.
func (m *RepositoryMutation) ResetInstallID() {
	m.install_id = nil
	m.addinstall_id = nil
	delete(m.clearedFields, repository.FieldInstallID)
}

// SetURL sets the "url" field.
func (m *RepositoryMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *RepositoryMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *RepositoryMutation) ClearURL() {
	m.url = nil
	m.clearedFields[repository.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *RepositoryMutation) URLCleared() bool {
	_, ok := m.clearedFields[repository.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *RepositoryMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, repository.FieldURL)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *RepositoryMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *RepositoryMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldAvatarURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *RepositoryMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[repository.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *RepositoryMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[repository.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *RepositoryMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, repository.FieldAvatarURL)
}

// SetDefaultBranch sets the "default_branch" field.
func (m *RepositoryMutation) SetDefaultBranch(s string) {
	m.default_branch = &s
}

// DefaultBranch returns the value of the "default_branch" field in the mutation.
func (m *RepositoryMutation) DefaultBranch() (r string, exists bool) {
	v := m.default_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultBranch returns the old "default_branch" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDefaultBranch(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultBranch: %w", err)
	}
	return oldValue.DefaultBranch, nil
}

// ClearDefaultBranch clears the value of the "default_branch" field.
func (m *RepositoryMutation) ClearDefaultBranch() {
	m.default_branch = nil
	m.clearedFields[repository.FieldDefaultBranch] = struct{}{}
}

// DefaultBranchCleared returns if the "default_branch" field was cleared in this mutation.
func (m *RepositoryMutation) DefaultBranchCleared() bool {
	_, ok := m.clearedFields[repository.FieldDefaultBranch]
	return ok
}

// ResetDefaultBranch resets all changes to the "default_branch" field.
func (m *RepositoryMutation) ResetDefaultBranch() {
	m.default_branch = nil
	delete(m.clearedFields, repository.FieldDefaultBranch)
}

// AddScanIDs adds the "scan" edge to the Scan entity by ids.
func (m *RepositoryMutation) AddScanIDs(ids ...string) {
	if m.scan == nil {
		m.scan = make(map[string]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the Scan entity.
func (m *RepositoryMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the Scan entity was cleared.
func (m *RepositoryMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the Scan entity by IDs.
func (m *RepositoryMutation) RemoveScanIDs(ids ...string) {
	if m.removedscan == nil {
		m.removedscan = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the Scan entity.
func (m *RepositoryMutation) RemovedScanIDs() (ids []string) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *RepositoryMutation) ScanIDs() (ids []string) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *RepositoryMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// AddMainIDs adds the "main" edge to the Scan entity by ids.
func (m *RepositoryMutation) AddMainIDs(ids ...string) {
	if m.main == nil {
		m.main = make(map[string]struct{})
	}
	for i := range ids {
		m.main[ids[i]] = struct{}{}
	}
}

// ClearMain clears the "main" edge to the Scan entity.
func (m *RepositoryMutation) ClearMain() {
	m.clearedmain = true
}

// MainCleared reports if the "main" edge to the Scan entity was cleared.
func (m *RepositoryMutation) MainCleared() bool {
	return m.clearedmain
}

// RemoveMainIDs removes the "main" edge to the Scan entity by IDs.
func (m *RepositoryMutation) RemoveMainIDs(ids ...string) {
	if m.removedmain == nil {
		m.removedmain = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.main, ids[i])
		m.removedmain[ids[i]] = struct{}{}
	}
}

// RemovedMain returns the removed IDs of the "main" edge to the Scan entity.
func (m *RepositoryMutation) RemovedMainIDs() (ids []string) {
	for id := range m.removedmain {
		ids = append(ids, id)
	}
	return
}

// MainIDs returns the "main" edge IDs in the mutation.
func (m *RepositoryMutation) MainIDs() (ids []string) {
	for id := range m.main {
		ids = append(ids, id)
	}
	return
}

// ResetMain resets all changes to the "main" edge.
func (m *RepositoryMutation) ResetMain() {
	m.main = nil
	m.clearedmain = false
	m.removedmain = nil
}

// SetLatestID sets the "latest" edge to the Scan entity by id.
func (m *RepositoryMutation) SetLatestID(id string) {
	m.latest = &id
}

// ClearLatest clears the "latest" edge to the Scan entity.
func (m *RepositoryMutation) ClearLatest() {
	m.clearedlatest = true
}

// LatestCleared reports if the "latest" edge to the Scan entity was cleared.
func (m *RepositoryMutation) LatestCleared() bool {
	return m.clearedlatest
}

// LatestID returns the "latest" edge ID in the mutation.
func (m *RepositoryMutation) LatestID() (id string, exists bool) {
	if m.latest != nil {
		return *m.latest, true
	}
	return
}

// LatestIDs returns the "latest" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LatestID instead. It exists only for internal usage by the builders.
func (m *RepositoryMutation) LatestIDs() (ids []string) {
	if id := m.latest; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLatest resets all changes to the "latest" edge.
func (m *RepositoryMutation) ResetLatest() {
	m.latest = nil
	m.clearedlatest = false
}

// AddStatuIDs adds the "status" edge to the VulnStatusIndex entity by ids.
func (m *RepositoryMutation) AddStatuIDs(ids ...string) {
	if m.status == nil {
		m.status = make(map[string]struct{})
	}
	for i := range ids {
		m.status[ids[i]] = struct{}{}
	}
}

// ClearStatus clears the "status" edge to the VulnStatusIndex entity.
func (m *RepositoryMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared reports if the "status" edge to the VulnStatusIndex entity was cleared.
func (m *RepositoryMutation) StatusCleared() bool {
	return m.clearedstatus
}

// RemoveStatuIDs removes the "status" edge to the VulnStatusIndex entity by IDs.
func (m *RepositoryMutation) RemoveStatuIDs(ids ...string) {
	if m.removedstatus == nil {
		m.removedstatus = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.status, ids[i])
		m.removedstatus[ids[i]] = struct{}{}
	}
}

// RemovedStatus returns the removed IDs of the "status" edge to the VulnStatusIndex entity.
func (m *RepositoryMutation) RemovedStatusIDs() (ids []string) {
	for id := range m.removedstatus {
		ids = append(ids, id)
	}
	return
}

// StatusIDs returns the "status" edge IDs in the mutation.
func (m *RepositoryMutation) StatusIDs() (ids []string) {
	for id := range m.status {
		ids = append(ids, id)
	}
	return
}

// ResetStatus resets all changes to the "status" edge.
func (m *RepositoryMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
	m.removedstatus = nil
}

// Where appends a list predicates to the RepositoryMutation builder.
func (m *RepositoryMutation) Where(ps ...predicate.Repository) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RepositoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repository).
func (m *RepositoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.owner != nil {
		fields = append(fields, repository.FieldOwner)
	}
	if m.name != nil {
		fields = append(fields, repository.FieldName)
	}
	if m.install_id != nil {
		fields = append(fields, repository.FieldInstallID)
	}
	if m.url != nil {
		fields = append(fields, repository.FieldURL)
	}
	if m.avatar_url != nil {
		fields = append(fields, repository.FieldAvatarURL)
	}
	if m.default_branch != nil {
		fields = append(fields, repository.FieldDefaultBranch)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldOwner:
		return m.Owner()
	case repository.FieldName:
		return m.Name()
	case repository.FieldInstallID:
		return m.InstallID()
	case repository.FieldURL:
		return m.URL()
	case repository.FieldAvatarURL:
		return m.AvatarURL()
	case repository.FieldDefaultBranch:
		return m.DefaultBranch()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repository.FieldOwner:
		return m.OldOwner(ctx)
	case repository.FieldName:
		return m.OldName(ctx)
	case repository.FieldInstallID:
		return m.OldInstallID(ctx)
	case repository.FieldURL:
		return m.OldURL(ctx)
	case repository.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case repository.FieldDefaultBranch:
		return m.OldDefaultBranch(ctx)
	}
	return nil, fmt.Errorf("unknown Repository field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repository.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case repository.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case repository.FieldInstallID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallID(v)
		return nil
	case repository.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case repository.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case repository.FieldDefaultBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultBranch(v)
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryMutation) AddedFields() []string {
	var fields []string
	if m.addinstall_id != nil {
		fields = append(fields, repository.FieldInstallID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldInstallID:
		return m.AddedInstallID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repository.FieldInstallID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInstallID(v)
		return nil
	}
	return fmt.Errorf("unknown Repository numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(repository.FieldInstallID) {
		fields = append(fields, repository.FieldInstallID)
	}
	if m.FieldCleared(repository.FieldURL) {
		fields = append(fields, repository.FieldURL)
	}
	if m.FieldCleared(repository.FieldAvatarURL) {
		fields = append(fields, repository.FieldAvatarURL)
	}
	if m.FieldCleared(repository.FieldDefaultBranch) {
		fields = append(fields, repository.FieldDefaultBranch)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryMutation) ClearField(name string) error {
	switch name {
	case repository.FieldInstallID:
		m.ClearInstallID()
		return nil
	case repository.FieldURL:
		m.ClearURL()
		return nil
	case repository.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case repository.FieldDefaultBranch:
		m.ClearDefaultBranch()
		return nil
	}
	return fmt.Errorf("unknown Repository nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryMutation) ResetField(name string) error {
	switch name {
	case repository.FieldOwner:
		m.ResetOwner()
		return nil
	case repository.FieldName:
		m.ResetName()
		return nil
	case repository.FieldInstallID:
		m.ResetInstallID()
		return nil
	case repository.FieldURL:
		m.ResetURL()
		return nil
	case repository.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case repository.FieldDefaultBranch:
		m.ResetDefaultBranch()
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.scan != nil {
		edges = append(edges, repository.EdgeScan)
	}
	if m.main != nil {
		edges = append(edges, repository.EdgeMain)
	}
	if m.latest != nil {
		edges = append(edges, repository.EdgeLatest)
	}
	if m.status != nil {
		edges = append(edges, repository.EdgeStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeMain:
		ids := make([]ent.Value, 0, len(m.main))
		for id := range m.main {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeLatest:
		if id := m.latest; id != nil {
			return []ent.Value{*id}
		}
	case repository.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.status))
		for id := range m.status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedscan != nil {
		edges = append(edges, repository.EdgeScan)
	}
	if m.removedmain != nil {
		edges = append(edges, repository.EdgeMain)
	}
	if m.removedstatus != nil {
		edges = append(edges, repository.EdgeStatus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeMain:
		ids := make([]ent.Value, 0, len(m.removedmain))
		for id := range m.removedmain {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.removedstatus))
		for id := range m.removedstatus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedscan {
		edges = append(edges, repository.EdgeScan)
	}
	if m.clearedmain {
		edges = append(edges, repository.EdgeMain)
	}
	if m.clearedlatest {
		edges = append(edges, repository.EdgeLatest)
	}
	if m.clearedstatus {
		edges = append(edges, repository.EdgeStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryMutation) EdgeCleared(name string) bool {
	switch name {
	case repository.EdgeScan:
		return m.clearedscan
	case repository.EdgeMain:
		return m.clearedmain
	case repository.EdgeLatest:
		return m.clearedlatest
	case repository.EdgeStatus:
		return m.clearedstatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryMutation) ClearEdge(name string) error {
	switch name {
	case repository.EdgeLatest:
		m.ClearLatest()
		return nil
	}
	return fmt.Errorf("unknown Repository unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryMutation) ResetEdge(name string) error {
	switch name {
	case repository.EdgeScan:
		m.ResetScan()
		return nil
	case repository.EdgeMain:
		m.ResetMain()
		return nil
	case repository.EdgeLatest:
		m.ResetLatest()
		return nil
	case repository.EdgeStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Repository edge %s", name)
}

// ScanMutation represents an operation that mutates the Scan nodes in the graph.
type ScanMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	branch              *string
	commit_id           *string
	requested_at        *int64
	addrequested_at     *int64
	scanned_at          *int64
	addscanned_at       *int64
	check_id            *int64
	addcheck_id         *int64
	pull_request_target *string
	clearedFields       map[string]struct{}
	repository          map[int]struct{}
	removedrepository   map[int]struct{}
	clearedrepository   bool
	packages            map[int]struct{}
	removedpackages     map[int]struct{}
	clearedpackages     bool
	done                bool
	oldValue            func(context.Context) (*Scan, error)
	predicates          []predicate.Scan
}

var _ ent.Mutation = (*ScanMutation)(nil)

// scanOption allows management of the mutation configuration using functional options.
type scanOption func(*ScanMutation)

// newScanMutation creates new mutation for the Scan entity.
func newScanMutation(c config, op Op, opts ...scanOption) *ScanMutation {
	m := &ScanMutation{
		config:        c,
		op:            op,
		typ:           TypeScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScanID sets the ID field of the mutation.
func withScanID(id string) scanOption {
	return func(m *ScanMutation) {
		var (
			err   error
			once  sync.Once
			value *Scan
		)
		m.oldValue = func(ctx context.Context) (*Scan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScan sets the old Scan of the mutation.
func withScan(node *Scan) scanOption {
	return func(m *ScanMutation) {
		m.oldValue = func(context.Context) (*Scan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Scan entities.
func (m *ScanMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScanMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBranch sets the "branch" field.
func (m *ScanMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the value of the "branch" field in the mutation.
func (m *ScanMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old "branch" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch resets all changes to the "branch" field.
func (m *ScanMutation) ResetBranch() {
	m.branch = nil
}

// SetCommitID sets the "commit_id" field.
func (m *ScanMutation) SetCommitID(s string) {
	m.commit_id = &s
}

// CommitID returns the value of the "commit_id" field in the mutation.
func (m *ScanMutation) CommitID() (r string, exists bool) {
	v := m.commit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitID returns the old "commit_id" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldCommitID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitID: %w", err)
	}
	return oldValue.CommitID, nil
}

// ResetCommitID resets all changes to the "commit_id" field.
func (m *ScanMutation) ResetCommitID() {
	m.commit_id = nil
}

// SetRequestedAt sets the "requested_at" field.
func (m *ScanMutation) SetRequestedAt(i int64) {
	m.requested_at = &i
	m.addrequested_at = nil
}

// RequestedAt returns the value of the "requested_at" field in the mutation.
func (m *ScanMutation) RequestedAt() (r int64, exists bool) {
	v := m.requested_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedAt returns the old "requested_at" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldRequestedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRequestedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRequestedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedAt: %w", err)
	}
	return oldValue.RequestedAt, nil
}

// AddRequestedAt adds i to the "requested_at" field.
func (m *ScanMutation) AddRequestedAt(i int64) {
	if m.addrequested_at != nil {
		*m.addrequested_at += i
	} else {
		m.addrequested_at = &i
	}
}

// AddedRequestedAt returns the value that was added to the "requested_at" field in this mutation.
func (m *ScanMutation) AddedRequestedAt() (r int64, exists bool) {
	v := m.addrequested_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequestedAt resets all changes to the "requested_at" field.
func (m *ScanMutation) ResetRequestedAt() {
	m.requested_at = nil
	m.addrequested_at = nil
}

// SetScannedAt sets the "scanned_at" field.
func (m *ScanMutation) SetScannedAt(i int64) {
	m.scanned_at = &i
	m.addscanned_at = nil
}

// ScannedAt returns the value of the "scanned_at" field in the mutation.
func (m *ScanMutation) ScannedAt() (r int64, exists bool) {
	v := m.scanned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScannedAt returns the old "scanned_at" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldScannedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScannedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScannedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScannedAt: %w", err)
	}
	return oldValue.ScannedAt, nil
}

// AddScannedAt adds i to the "scanned_at" field.
func (m *ScanMutation) AddScannedAt(i int64) {
	if m.addscanned_at != nil {
		*m.addscanned_at += i
	} else {
		m.addscanned_at = &i
	}
}

// AddedScannedAt returns the value that was added to the "scanned_at" field in this mutation.
func (m *ScanMutation) AddedScannedAt() (r int64, exists bool) {
	v := m.addscanned_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetScannedAt resets all changes to the "scanned_at" field.
func (m *ScanMutation) ResetScannedAt() {
	m.scanned_at = nil
	m.addscanned_at = nil
}

// SetCheckID sets the "check_id" field.
func (m *ScanMutation) SetCheckID(i int64) {
	m.check_id = &i
	m.addcheck_id = nil
}

// CheckID returns the value of the "check_id" field in the mutation.
func (m *ScanMutation) CheckID() (r int64, exists bool) {
	v := m.check_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckID returns the old "check_id" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldCheckID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckID: %w", err)
	}
	return oldValue.CheckID, nil
}

// AddCheckID adds i to the "check_id" field.
func (m *ScanMutation) AddCheckID(i int64) {
	if m.addcheck_id != nil {
		*m.addcheck_id += i
	} else {
		m.addcheck_id = &i
	}
}

// AddedCheckID returns the value that was added to the "check_id" field in this mutation.
func (m *ScanMutation) AddedCheckID() (r int64, exists bool) {
	v := m.addcheck_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCheckID clears the value of the "check_id" field.
func (m *ScanMutation) ClearCheckID() {
	m.check_id = nil
	m.addcheck_id = nil
	m.clearedFields[scan.FieldCheckID] = struct{}{}
}

// CheckIDCleared returns if the "check_id" field was cleared in this mutation.
func (m *ScanMutation) CheckIDCleared() bool {
	_, ok := m.clearedFields[scan.FieldCheckID]
	return ok
}

// ResetCheckID resets all changes to the "check_id" field.
func (m *ScanMutation) ResetCheckID() {
	m.check_id = nil
	m.addcheck_id = nil
	delete(m.clearedFields, scan.FieldCheckID)
}

// SetPullRequestTarget sets the "pull_request_target" field.
func (m *ScanMutation) SetPullRequestTarget(s string) {
	m.pull_request_target = &s
}

// PullRequestTarget returns the value of the "pull_request_target" field in the mutation.
func (m *ScanMutation) PullRequestTarget() (r string, exists bool) {
	v := m.pull_request_target
	if v == nil {
		return
	}
	return *v, true
}

// OldPullRequestTarget returns the old "pull_request_target" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldPullRequestTarget(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPullRequestTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPullRequestTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullRequestTarget: %w", err)
	}
	return oldValue.PullRequestTarget, nil
}

// ClearPullRequestTarget clears the value of the "pull_request_target" field.
func (m *ScanMutation) ClearPullRequestTarget() {
	m.pull_request_target = nil
	m.clearedFields[scan.FieldPullRequestTarget] = struct{}{}
}

// PullRequestTargetCleared returns if the "pull_request_target" field was cleared in this mutation.
func (m *ScanMutation) PullRequestTargetCleared() bool {
	_, ok := m.clearedFields[scan.FieldPullRequestTarget]
	return ok
}

// ResetPullRequestTarget resets all changes to the "pull_request_target" field.
func (m *ScanMutation) ResetPullRequestTarget() {
	m.pull_request_target = nil
	delete(m.clearedFields, scan.FieldPullRequestTarget)
}

// AddRepositoryIDs adds the "repository" edge to the Repository entity by ids.
func (m *ScanMutation) AddRepositoryIDs(ids ...int) {
	if m.repository == nil {
		m.repository = make(map[int]struct{})
	}
	for i := range ids {
		m.repository[ids[i]] = struct{}{}
	}
}

// ClearRepository clears the "repository" edge to the Repository entity.
func (m *ScanMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the Repository entity was cleared.
func (m *ScanMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RemoveRepositoryIDs removes the "repository" edge to the Repository entity by IDs.
func (m *ScanMutation) RemoveRepositoryIDs(ids ...int) {
	if m.removedrepository == nil {
		m.removedrepository = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repository, ids[i])
		m.removedrepository[ids[i]] = struct{}{}
	}
}

// RemovedRepository returns the removed IDs of the "repository" edge to the Repository entity.
func (m *ScanMutation) RemovedRepositoryIDs() (ids []int) {
	for id := range m.removedrepository {
		ids = append(ids, id)
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
func (m *ScanMutation) RepositoryIDs() (ids []int) {
	for id := range m.repository {
		ids = append(ids, id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *ScanMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
	m.removedrepository = nil
}

// AddPackageIDs adds the "packages" edge to the PackageRecord entity by ids.
func (m *ScanMutation) AddPackageIDs(ids ...int) {
	if m.packages == nil {
		m.packages = make(map[int]struct{})
	}
	for i := range ids {
		m.packages[ids[i]] = struct{}{}
	}
}

// ClearPackages clears the "packages" edge to the PackageRecord entity.
func (m *ScanMutation) ClearPackages() {
	m.clearedpackages = true
}

// PackagesCleared reports if the "packages" edge to the PackageRecord entity was cleared.
func (m *ScanMutation) PackagesCleared() bool {
	return m.clearedpackages
}

// RemovePackageIDs removes the "packages" edge to the PackageRecord entity by IDs.
func (m *ScanMutation) RemovePackageIDs(ids ...int) {
	if m.removedpackages == nil {
		m.removedpackages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.packages, ids[i])
		m.removedpackages[ids[i]] = struct{}{}
	}
}

// RemovedPackages returns the removed IDs of the "packages" edge to the PackageRecord entity.
func (m *ScanMutation) RemovedPackagesIDs() (ids []int) {
	for id := range m.removedpackages {
		ids = append(ids, id)
	}
	return
}

// PackagesIDs returns the "packages" edge IDs in the mutation.
func (m *ScanMutation) PackagesIDs() (ids []int) {
	for id := range m.packages {
		ids = append(ids, id)
	}
	return
}

// ResetPackages resets all changes to the "packages" edge.
func (m *ScanMutation) ResetPackages() {
	m.packages = nil
	m.clearedpackages = false
	m.removedpackages = nil
}

// Where appends a list predicates to the ScanMutation builder.
func (m *ScanMutation) Where(ps ...predicate.Scan) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Scan).
func (m *ScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScanMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.branch != nil {
		fields = append(fields, scan.FieldBranch)
	}
	if m.commit_id != nil {
		fields = append(fields, scan.FieldCommitID)
	}
	if m.requested_at != nil {
		fields = append(fields, scan.FieldRequestedAt)
	}
	if m.scanned_at != nil {
		fields = append(fields, scan.FieldScannedAt)
	}
	if m.check_id != nil {
		fields = append(fields, scan.FieldCheckID)
	}
	if m.pull_request_target != nil {
		fields = append(fields, scan.FieldPullRequestTarget)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scan.FieldBranch:
		return m.Branch()
	case scan.FieldCommitID:
		return m.CommitID()
	case scan.FieldRequestedAt:
		return m.RequestedAt()
	case scan.FieldScannedAt:
		return m.ScannedAt()
	case scan.FieldCheckID:
		return m.CheckID()
	case scan.FieldPullRequestTarget:
		return m.PullRequestTarget()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scan.FieldBranch:
		return m.OldBranch(ctx)
	case scan.FieldCommitID:
		return m.OldCommitID(ctx)
	case scan.FieldRequestedAt:
		return m.OldRequestedAt(ctx)
	case scan.FieldScannedAt:
		return m.OldScannedAt(ctx)
	case scan.FieldCheckID:
		return m.OldCheckID(ctx)
	case scan.FieldPullRequestTarget:
		return m.OldPullRequestTarget(ctx)
	}
	return nil, fmt.Errorf("unknown Scan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scan.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case scan.FieldCommitID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitID(v)
		return nil
	case scan.FieldRequestedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedAt(v)
		return nil
	case scan.FieldScannedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScannedAt(v)
		return nil
	case scan.FieldCheckID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckID(v)
		return nil
	case scan.FieldPullRequestTarget:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullRequestTarget(v)
		return nil
	}
	return fmt.Errorf("unknown Scan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScanMutation) AddedFields() []string {
	var fields []string
	if m.addrequested_at != nil {
		fields = append(fields, scan.FieldRequestedAt)
	}
	if m.addscanned_at != nil {
		fields = append(fields, scan.FieldScannedAt)
	}
	if m.addcheck_id != nil {
		fields = append(fields, scan.FieldCheckID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scan.FieldRequestedAt:
		return m.AddedRequestedAt()
	case scan.FieldScannedAt:
		return m.AddedScannedAt()
	case scan.FieldCheckID:
		return m.AddedCheckID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scan.FieldRequestedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestedAt(v)
		return nil
	case scan.FieldScannedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScannedAt(v)
		return nil
	case scan.FieldCheckID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCheckID(v)
		return nil
	}
	return fmt.Errorf("unknown Scan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scan.FieldCheckID) {
		fields = append(fields, scan.FieldCheckID)
	}
	if m.FieldCleared(scan.FieldPullRequestTarget) {
		fields = append(fields, scan.FieldPullRequestTarget)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScanMutation) ClearField(name string) error {
	switch name {
	case scan.FieldCheckID:
		m.ClearCheckID()
		return nil
	case scan.FieldPullRequestTarget:
		m.ClearPullRequestTarget()
		return nil
	}
	return fmt.Errorf("unknown Scan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScanMutation) ResetField(name string) error {
	switch name {
	case scan.FieldBranch:
		m.ResetBranch()
		return nil
	case scan.FieldCommitID:
		m.ResetCommitID()
		return nil
	case scan.FieldRequestedAt:
		m.ResetRequestedAt()
		return nil
	case scan.FieldScannedAt:
		m.ResetScannedAt()
		return nil
	case scan.FieldCheckID:
		m.ResetCheckID()
		return nil
	case scan.FieldPullRequestTarget:
		m.ResetPullRequestTarget()
		return nil
	}
	return fmt.Errorf("unknown Scan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.repository != nil {
		edges = append(edges, scan.EdgeRepository)
	}
	if m.packages != nil {
		edges = append(edges, scan.EdgePackages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scan.EdgeRepository:
		ids := make([]ent.Value, 0, len(m.repository))
		for id := range m.repository {
			ids = append(ids, id)
		}
		return ids
	case scan.EdgePackages:
		ids := make([]ent.Value, 0, len(m.packages))
		for id := range m.packages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrepository != nil {
		edges = append(edges, scan.EdgeRepository)
	}
	if m.removedpackages != nil {
		edges = append(edges, scan.EdgePackages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scan.EdgeRepository:
		ids := make([]ent.Value, 0, len(m.removedrepository))
		for id := range m.removedrepository {
			ids = append(ids, id)
		}
		return ids
	case scan.EdgePackages:
		ids := make([]ent.Value, 0, len(m.removedpackages))
		for id := range m.removedpackages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrepository {
		edges = append(edges, scan.EdgeRepository)
	}
	if m.clearedpackages {
		edges = append(edges, scan.EdgePackages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScanMutation) EdgeCleared(name string) bool {
	switch name {
	case scan.EdgeRepository:
		return m.clearedrepository
	case scan.EdgePackages:
		return m.clearedpackages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Scan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScanMutation) ResetEdge(name string) error {
	switch name {
	case scan.EdgeRepository:
		m.ResetRepository()
		return nil
	case scan.EdgePackages:
		m.ResetPackages()
		return nil
	}
	return fmt.Errorf("unknown Scan edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	user_id       *int
	adduser_id    *int
	token         *string
	created_at    *int64
	addcreated_at *int64
	expires_at    *int64
	addexpires_at *int64
	clearedFields map[string]struct{}
	login         *int
	clearedlogin  bool
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *SessionMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *SessionMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetToken sets the "token" field.
func (m *SessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *SessionMutation) ResetToken() {
	m.token = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *SessionMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SessionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(i int64) {
	m.expires_at = &i
	m.addexpires_at = nil
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r int64, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// AddExpiresAt adds i to the "expires_at" field.
func (m *SessionMutation) AddExpiresAt(i int64) {
	if m.addexpires_at != nil {
		*m.addexpires_at += i
	} else {
		m.addexpires_at = &i
	}
}

// AddedExpiresAt returns the value that was added to the "expires_at" field in this mutation.
func (m *SessionMutation) AddedExpiresAt() (r int64, exists bool) {
	v := m.addexpires_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
	m.addexpires_at = nil
}

// SetLoginID sets the "login" edge to the User entity by id.
func (m *SessionMutation) SetLoginID(id int) {
	m.login = &id
}

// ClearLogin clears the "login" edge to the User entity.
func (m *SessionMutation) ClearLogin() {
	m.clearedlogin = true
}

// LoginCleared reports if the "login" edge to the User entity was cleared.
func (m *SessionMutation) LoginCleared() bool {
	return m.clearedlogin
}

// LoginID returns the "login" edge ID in the mutation.
func (m *SessionMutation) LoginID() (id int, exists bool) {
	if m.login != nil {
		return *m.login, true
	}
	return
}

// LoginIDs returns the "login" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LoginID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) LoginIDs() (ids []int) {
	if id := m.login; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLogin resets all changes to the "login" edge.
func (m *SessionMutation) ResetLogin() {
	m.login = nil
	m.clearedlogin = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user_id != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.token != nil {
		fields = append(fields, session.FieldToken)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.UserID()
	case session.FieldToken:
		return m.Token()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldToken:
		return m.OldToken(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.addcreated_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.addexpires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.AddedUserID()
	case session.FieldCreatedAt:
		return m.AddedCreatedAt()
	case session.FieldExpiresAt:
		return m.AddedExpiresAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldToken:
		m.ResetToken()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.login != nil {
		edges = append(edges, session.EdgeLogin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeLogin:
		if id := m.login; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlogin {
		edges = append(edges, session.EdgeLogin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeLogin:
		return m.clearedlogin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeLogin:
		m.ClearLogin()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeLogin:
		m.ResetLogin()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	github_id            *int64
	addgithub_id         *int64
	login                *string
	name                 *string
	avatar_url           *string
	url                  *string
	clearedFields        map[string]struct{}
	edited_status        map[int]struct{}
	removededited_status map[int]struct{}
	clearededited_status bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGithubID sets the "github_id" field.
func (m *UserMutation) SetGithubID(i int64) {
	m.github_id = &i
	m.addgithub_id = nil
}

// GithubID returns the value of the "github_id" field in the mutation.
func (m *UserMutation) GithubID() (r int64, exists bool) {
	v := m.github_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubID returns the old "github_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGithubID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGithubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGithubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubID: %w", err)
	}
	return oldValue.GithubID, nil
}

// AddGithubID adds i to the "github_id" field.
func (m *UserMutation) AddGithubID(i int64) {
	if m.addgithub_id != nil {
		*m.addgithub_id += i
	} else {
		m.addgithub_id = &i
	}
}

// AddedGithubID returns the value that was added to the "github_id" field in this mutation.
func (m *UserMutation) AddedGithubID() (r int64, exists bool) {
	v := m.addgithub_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGithubID resets all changes to the "github_id" field.
func (m *UserMutation) ResetGithubID() {
	m.github_id = nil
	m.addgithub_id = nil
}

// SetLogin sets the "login" field.
func (m *UserMutation) SetLogin(s string) {
	m.login = &s
}

// Login returns the value of the "login" field in the mutation.
func (m *UserMutation) Login() (r string, exists bool) {
	v := m.login
	if v == nil {
		return
	}
	return *v, true
}

// OldLogin returns the old "login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogin: %w", err)
	}
	return oldValue.Login, nil
}

// ResetLogin resets all changes to the "login" field.
func (m *UserMutation) ResetLogin() {
	m.login = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetURL sets the "url" field.
func (m *UserMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *UserMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *UserMutation) ResetURL() {
	m.url = nil
}

// AddEditedStatuIDs adds the "edited_status" edge to the VulnStatus entity by ids.
func (m *UserMutation) AddEditedStatuIDs(ids ...int) {
	if m.edited_status == nil {
		m.edited_status = make(map[int]struct{})
	}
	for i := range ids {
		m.edited_status[ids[i]] = struct{}{}
	}
}

// ClearEditedStatus clears the "edited_status" edge to the VulnStatus entity.
func (m *UserMutation) ClearEditedStatus() {
	m.clearededited_status = true
}

// EditedStatusCleared reports if the "edited_status" edge to the VulnStatus entity was cleared.
func (m *UserMutation) EditedStatusCleared() bool {
	return m.clearededited_status
}

// RemoveEditedStatuIDs removes the "edited_status" edge to the VulnStatus entity by IDs.
func (m *UserMutation) RemoveEditedStatuIDs(ids ...int) {
	if m.removededited_status == nil {
		m.removededited_status = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.edited_status, ids[i])
		m.removededited_status[ids[i]] = struct{}{}
	}
}

// RemovedEditedStatus returns the removed IDs of the "edited_status" edge to the VulnStatus entity.
func (m *UserMutation) RemovedEditedStatusIDs() (ids []int) {
	for id := range m.removededited_status {
		ids = append(ids, id)
	}
	return
}

// EditedStatusIDs returns the "edited_status" edge IDs in the mutation.
func (m *UserMutation) EditedStatusIDs() (ids []int) {
	for id := range m.edited_status {
		ids = append(ids, id)
	}
	return
}

// ResetEditedStatus resets all changes to the "edited_status" edge.
func (m *UserMutation) ResetEditedStatus() {
	m.edited_status = nil
	m.clearededited_status = false
	m.removededited_status = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.github_id != nil {
		fields = append(fields, user.FieldGithubID)
	}
	if m.login != nil {
		fields = append(fields, user.FieldLogin)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.url != nil {
		fields = append(fields, user.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldGithubID:
		return m.GithubID()
	case user.FieldLogin:
		return m.Login()
	case user.FieldName:
		return m.Name()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldGithubID:
		return m.OldGithubID(ctx)
	case user.FieldLogin:
		return m.OldLogin(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldGithubID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubID(v)
		return nil
	case user.FieldLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogin(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addgithub_id != nil {
		fields = append(fields, user.FieldGithubID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldGithubID:
		return m.AddedGithubID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldGithubID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGithubID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldGithubID:
		m.ResetGithubID()
		return nil
	case user.FieldLogin:
		m.ResetLogin()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.edited_status != nil {
		edges = append(edges, user.EdgeEditedStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEditedStatus:
		ids := make([]ent.Value, 0, len(m.edited_status))
		for id := range m.edited_status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removededited_status != nil {
		edges = append(edges, user.EdgeEditedStatus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEditedStatus:
		ids := make([]ent.Value, 0, len(m.removededited_status))
		for id := range m.removededited_status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearededited_status {
		edges = append(edges, user.EdgeEditedStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeEditedStatus:
		return m.clearededited_status
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeEditedStatus:
		m.ResetEditedStatus()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VulnStatusMutation represents an operation that mutates the VulnStatus nodes in the graph.
type VulnStatusMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *types.VulnStatusType
	source        *string
	pkg_name      *string
	pkg_type      *string
	vuln_id       *string
	expires_at    *int64
	addexpires_at *int64
	created_at    *int64
	addcreated_at *int64
	comment       *string
	clearedFields map[string]struct{}
	author        *int
	clearedauthor bool
	done          bool
	oldValue      func(context.Context) (*VulnStatus, error)
	predicates    []predicate.VulnStatus
}

var _ ent.Mutation = (*VulnStatusMutation)(nil)

// vulnstatusOption allows management of the mutation configuration using functional options.
type vulnstatusOption func(*VulnStatusMutation)

// newVulnStatusMutation creates new mutation for the VulnStatus entity.
func newVulnStatusMutation(c config, op Op, opts ...vulnstatusOption) *VulnStatusMutation {
	m := &VulnStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnStatusID sets the ID field of the mutation.
func withVulnStatusID(id int) vulnstatusOption {
	return func(m *VulnStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnStatus
		)
		m.oldValue = func(ctx context.Context) (*VulnStatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnStatus sets the old VulnStatus of the mutation.
func withVulnStatus(node *VulnStatus) vulnstatusOption {
	return func(m *VulnStatusMutation) {
		m.oldValue = func(context.Context) (*VulnStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the "status" field.
func (m *VulnStatusMutation) SetStatus(tst types.VulnStatusType) {
	m.status = &tst
}

// Status returns the value of the "status" field in the mutation.
func (m *VulnStatusMutation) Status() (r types.VulnStatusType, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldStatus(ctx context.Context) (v types.VulnStatusType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VulnStatusMutation) ResetStatus() {
	m.status = nil
}

// SetSource sets the "source" field.
func (m *VulnStatusMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *VulnStatusMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *VulnStatusMutation) ResetSource() {
	m.source = nil
}

// SetPkgName sets the "pkg_name" field.
func (m *VulnStatusMutation) SetPkgName(s string) {
	m.pkg_name = &s
}

// PkgName returns the value of the "pkg_name" field in the mutation.
func (m *VulnStatusMutation) PkgName() (r string, exists bool) {
	v := m.pkg_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgName returns the old "pkg_name" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldPkgName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPkgName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPkgName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgName: %w", err)
	}
	return oldValue.PkgName, nil
}

// ResetPkgName resets all changes to the "pkg_name" field.
func (m *VulnStatusMutation) ResetPkgName() {
	m.pkg_name = nil
}

// SetPkgType sets the "pkg_type" field.
func (m *VulnStatusMutation) SetPkgType(s string) {
	m.pkg_type = &s
}

// PkgType returns the value of the "pkg_type" field in the mutation.
func (m *VulnStatusMutation) PkgType() (r string, exists bool) {
	v := m.pkg_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgType returns the old "pkg_type" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldPkgType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPkgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPkgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgType: %w", err)
	}
	return oldValue.PkgType, nil
}

// ResetPkgType resets all changes to the "pkg_type" field.
func (m *VulnStatusMutation) ResetPkgType() {
	m.pkg_type = nil
}

// SetVulnID sets the "vuln_id" field.
func (m *VulnStatusMutation) SetVulnID(s string) {
	m.vuln_id = &s
}

// VulnID returns the value of the "vuln_id" field in the mutation.
func (m *VulnStatusMutation) VulnID() (r string, exists bool) {
	v := m.vuln_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnID returns the old "vuln_id" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldVulnID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVulnID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVulnID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnID: %w", err)
	}
	return oldValue.VulnID, nil
}

// ResetVulnID resets all changes to the "vuln_id" field.
func (m *VulnStatusMutation) ResetVulnID() {
	m.vuln_id = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *VulnStatusMutation) SetExpiresAt(i int64) {
	m.expires_at = &i
	m.addexpires_at = nil
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *VulnStatusMutation) ExpiresAt() (r int64, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldExpiresAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// AddExpiresAt adds i to the "expires_at" field.
func (m *VulnStatusMutation) AddExpiresAt(i int64) {
	if m.addexpires_at != nil {
		*m.addexpires_at += i
	} else {
		m.addexpires_at = &i
	}
}

// AddedExpiresAt returns the value that was added to the "expires_at" field in this mutation.
func (m *VulnStatusMutation) AddedExpiresAt() (r int64, exists bool) {
	v := m.addexpires_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *VulnStatusMutation) ResetExpiresAt() {
	m.expires_at = nil
	m.addexpires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VulnStatusMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VulnStatusMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *VulnStatusMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *VulnStatusMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VulnStatusMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetComment sets the "comment" field.
func (m *VulnStatusMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *VulnStatusMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *VulnStatusMutation) ResetComment() {
	m.comment = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *VulnStatusMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *VulnStatusMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *VulnStatusMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *VulnStatusMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *VulnStatusMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *VulnStatusMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the VulnStatusMutation builder.
func (m *VulnStatusMutation) Where(ps ...predicate.VulnStatus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VulnStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VulnStatus).
func (m *VulnStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnStatusMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.status != nil {
		fields = append(fields, vulnstatus.FieldStatus)
	}
	if m.source != nil {
		fields = append(fields, vulnstatus.FieldSource)
	}
	if m.pkg_name != nil {
		fields = append(fields, vulnstatus.FieldPkgName)
	}
	if m.pkg_type != nil {
		fields = append(fields, vulnstatus.FieldPkgType)
	}
	if m.vuln_id != nil {
		fields = append(fields, vulnstatus.FieldVulnID)
	}
	if m.expires_at != nil {
		fields = append(fields, vulnstatus.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, vulnstatus.FieldCreatedAt)
	}
	if m.comment != nil {
		fields = append(fields, vulnstatus.FieldComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnstatus.FieldStatus:
		return m.Status()
	case vulnstatus.FieldSource:
		return m.Source()
	case vulnstatus.FieldPkgName:
		return m.PkgName()
	case vulnstatus.FieldPkgType:
		return m.PkgType()
	case vulnstatus.FieldVulnID:
		return m.VulnID()
	case vulnstatus.FieldExpiresAt:
		return m.ExpiresAt()
	case vulnstatus.FieldCreatedAt:
		return m.CreatedAt()
	case vulnstatus.FieldComment:
		return m.Comment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnstatus.FieldStatus:
		return m.OldStatus(ctx)
	case vulnstatus.FieldSource:
		return m.OldSource(ctx)
	case vulnstatus.FieldPkgName:
		return m.OldPkgName(ctx)
	case vulnstatus.FieldPkgType:
		return m.OldPkgType(ctx)
	case vulnstatus.FieldVulnID:
		return m.OldVulnID(ctx)
	case vulnstatus.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case vulnstatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vulnstatus.FieldComment:
		return m.OldComment(ctx)
	}
	return nil, fmt.Errorf("unknown VulnStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnstatus.FieldStatus:
		v, ok := value.(types.VulnStatusType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case vulnstatus.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case vulnstatus.FieldPkgName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgName(v)
		return nil
	case vulnstatus.FieldPkgType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgType(v)
		return nil
	case vulnstatus.FieldVulnID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnID(v)
		return nil
	case vulnstatus.FieldExpiresAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case vulnstatus.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vulnstatus.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	}
	return fmt.Errorf("unknown VulnStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnStatusMutation) AddedFields() []string {
	var fields []string
	if m.addexpires_at != nil {
		fields = append(fields, vulnstatus.FieldExpiresAt)
	}
	if m.addcreated_at != nil {
		fields = append(fields, vulnstatus.FieldCreatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vulnstatus.FieldExpiresAt:
		return m.AddedExpiresAt()
	case vulnstatus.FieldCreatedAt:
		return m.AddedCreatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vulnstatus.FieldExpiresAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiresAt(v)
		return nil
	case vulnstatus.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VulnStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VulnStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnStatusMutation) ResetField(name string) error {
	switch name {
	case vulnstatus.FieldStatus:
		m.ResetStatus()
		return nil
	case vulnstatus.FieldSource:
		m.ResetSource()
		return nil
	case vulnstatus.FieldPkgName:
		m.ResetPkgName()
		return nil
	case vulnstatus.FieldPkgType:
		m.ResetPkgType()
		return nil
	case vulnstatus.FieldVulnID:
		m.ResetVulnID()
		return nil
	case vulnstatus.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case vulnstatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vulnstatus.FieldComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown VulnStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.author != nil {
		edges = append(edges, vulnstatus.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnstatus.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauthor {
		edges = append(edges, vulnstatus.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnstatus.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnStatusMutation) ClearEdge(name string) error {
	switch name {
	case vulnstatus.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown VulnStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnStatusMutation) ResetEdge(name string) error {
	switch name {
	case vulnstatus.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown VulnStatus edge %s", name)
}

// VulnStatusIndexMutation represents an operation that mutates the VulnStatusIndex nodes in the graph.
type VulnStatusIndexMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	status        map[int]struct{}
	removedstatus map[int]struct{}
	clearedstatus bool
	done          bool
	oldValue      func(context.Context) (*VulnStatusIndex, error)
	predicates    []predicate.VulnStatusIndex
}

var _ ent.Mutation = (*VulnStatusIndexMutation)(nil)

// vulnstatusindexOption allows management of the mutation configuration using functional options.
type vulnstatusindexOption func(*VulnStatusIndexMutation)

// newVulnStatusIndexMutation creates new mutation for the VulnStatusIndex entity.
func newVulnStatusIndexMutation(c config, op Op, opts ...vulnstatusindexOption) *VulnStatusIndexMutation {
	m := &VulnStatusIndexMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnStatusIndex,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnStatusIndexID sets the ID field of the mutation.
func withVulnStatusIndexID(id string) vulnstatusindexOption {
	return func(m *VulnStatusIndexMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnStatusIndex
		)
		m.oldValue = func(ctx context.Context) (*VulnStatusIndex, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnStatusIndex.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnStatusIndex sets the old VulnStatusIndex of the mutation.
func withVulnStatusIndex(node *VulnStatusIndex) vulnstatusindexOption {
	return func(m *VulnStatusIndexMutation) {
		m.oldValue = func(context.Context) (*VulnStatusIndex, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnStatusIndexMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnStatusIndexMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VulnStatusIndex entities.
func (m *VulnStatusIndexMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnStatusIndexMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// AddStatuIDs adds the "status" edge to the VulnStatus entity by ids.
func (m *VulnStatusIndexMutation) AddStatuIDs(ids ...int) {
	if m.status == nil {
		m.status = make(map[int]struct{})
	}
	for i := range ids {
		m.status[ids[i]] = struct{}{}
	}
}

// ClearStatus clears the "status" edge to the VulnStatus entity.
func (m *VulnStatusIndexMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared reports if the "status" edge to the VulnStatus entity was cleared.
func (m *VulnStatusIndexMutation) StatusCleared() bool {
	return m.clearedstatus
}

// RemoveStatuIDs removes the "status" edge to the VulnStatus entity by IDs.
func (m *VulnStatusIndexMutation) RemoveStatuIDs(ids ...int) {
	if m.removedstatus == nil {
		m.removedstatus = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.status, ids[i])
		m.removedstatus[ids[i]] = struct{}{}
	}
}

// RemovedStatus returns the removed IDs of the "status" edge to the VulnStatus entity.
func (m *VulnStatusIndexMutation) RemovedStatusIDs() (ids []int) {
	for id := range m.removedstatus {
		ids = append(ids, id)
	}
	return
}

// StatusIDs returns the "status" edge IDs in the mutation.
func (m *VulnStatusIndexMutation) StatusIDs() (ids []int) {
	for id := range m.status {
		ids = append(ids, id)
	}
	return
}

// ResetStatus resets all changes to the "status" edge.
func (m *VulnStatusIndexMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
	m.removedstatus = nil
}

// Where appends a list predicates to the VulnStatusIndexMutation builder.
func (m *VulnStatusIndexMutation) Where(ps ...predicate.VulnStatusIndex) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VulnStatusIndexMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VulnStatusIndex).
func (m *VulnStatusIndexMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnStatusIndexMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnStatusIndexMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnStatusIndexMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown VulnStatusIndex field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnStatusIndexMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnStatusIndex field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnStatusIndexMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnStatusIndexMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnStatusIndexMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown VulnStatusIndex numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnStatusIndexMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnStatusIndexMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnStatusIndexMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VulnStatusIndex nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnStatusIndexMutation) ResetField(name string) error {
	return fmt.Errorf("unknown VulnStatusIndex field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnStatusIndexMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.status != nil {
		edges = append(edges, vulnstatusindex.EdgeStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnStatusIndexMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnstatusindex.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.status))
		for id := range m.status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnStatusIndexMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatus != nil {
		edges = append(edges, vulnstatusindex.EdgeStatus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnStatusIndexMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnstatusindex.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.removedstatus))
		for id := range m.removedstatus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnStatusIndexMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstatus {
		edges = append(edges, vulnstatusindex.EdgeStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnStatusIndexMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnstatusindex.EdgeStatus:
		return m.clearedstatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnStatusIndexMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnStatusIndex unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnStatusIndexMutation) ResetEdge(name string) error {
	switch name {
	case vulnstatusindex.EdgeStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown VulnStatusIndex edge %s", name)
}

// VulnerabilityMutation represents an operation that mutates the Vulnerability nodes in the graph.
type VulnerabilityMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	first_seen_at       *int64
	addfirst_seen_at    *int64
	last_modified_at    *int64
	addlast_modified_at *int64
	title               *string
	description         *string
	cwe_id              *[]string
	severity            *string
	cvss                *[]string
	references          *[]string
	fixed_version       *string
	clearedFields       map[string]struct{}
	packages            map[int]struct{}
	removedpackages     map[int]struct{}
	clearedpackages     bool
	status              map[int]struct{}
	removedstatus       map[int]struct{}
	clearedstatus       bool
	done                bool
	oldValue            func(context.Context) (*Vulnerability, error)
	predicates          []predicate.Vulnerability
}

var _ ent.Mutation = (*VulnerabilityMutation)(nil)

// vulnerabilityOption allows management of the mutation configuration using functional options.
type vulnerabilityOption func(*VulnerabilityMutation)

// newVulnerabilityMutation creates new mutation for the Vulnerability entity.
func newVulnerabilityMutation(c config, op Op, opts ...vulnerabilityOption) *VulnerabilityMutation {
	m := &VulnerabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityID sets the ID field of the mutation.
func withVulnerabilityID(id string) vulnerabilityOption {
	return func(m *VulnerabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Vulnerability
		)
		m.oldValue = func(ctx context.Context) (*Vulnerability, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vulnerability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerability sets the old Vulnerability of the mutation.
func withVulnerability(node *Vulnerability) vulnerabilityOption {
	return func(m *VulnerabilityMutation) {
		m.oldValue = func(context.Context) (*Vulnerability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vulnerability entities.
func (m *VulnerabilityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFirstSeenAt sets the "first_seen_at" field.
func (m *VulnerabilityMutation) SetFirstSeenAt(i int64) {
	m.first_seen_at = &i
	m.addfirst_seen_at = nil
}

// FirstSeenAt returns the value of the "first_seen_at" field in the mutation.
func (m *VulnerabilityMutation) FirstSeenAt() (r int64, exists bool) {
	v := m.first_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstSeenAt returns the old "first_seen_at" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldFirstSeenAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstSeenAt: %w", err)
	}
	return oldValue.FirstSeenAt, nil
}

// AddFirstSeenAt adds i to the "first_seen_at" field.
func (m *VulnerabilityMutation) AddFirstSeenAt(i int64) {
	if m.addfirst_seen_at != nil {
		*m.addfirst_seen_at += i
	} else {
		m.addfirst_seen_at = &i
	}
}

// AddedFirstSeenAt returns the value that was added to the "first_seen_at" field in this mutation.
func (m *VulnerabilityMutation) AddedFirstSeenAt() (r int64, exists bool) {
	v := m.addfirst_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstSeenAt resets all changes to the "first_seen_at" field.
func (m *VulnerabilityMutation) ResetFirstSeenAt() {
	m.first_seen_at = nil
	m.addfirst_seen_at = nil
}

// SetLastModifiedAt sets the "last_modified_at" field.
func (m *VulnerabilityMutation) SetLastModifiedAt(i int64) {
	m.last_modified_at = &i
	m.addlast_modified_at = nil
}

// LastModifiedAt returns the value of the "last_modified_at" field in the mutation.
func (m *VulnerabilityMutation) LastModifiedAt() (r int64, exists bool) {
	v := m.last_modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedAt returns the old "last_modified_at" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldLastModifiedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedAt: %w", err)
	}
	return oldValue.LastModifiedAt, nil
}

// AddLastModifiedAt adds i to the "last_modified_at" field.
func (m *VulnerabilityMutation) AddLastModifiedAt(i int64) {
	if m.addlast_modified_at != nil {
		*m.addlast_modified_at += i
	} else {
		m.addlast_modified_at = &i
	}
}

// AddedLastModifiedAt returns the value that was added to the "last_modified_at" field in this mutation.
func (m *VulnerabilityMutation) AddedLastModifiedAt() (r int64, exists bool) {
	v := m.addlast_modified_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastModifiedAt resets all changes to the "last_modified_at" field.
func (m *VulnerabilityMutation) ResetLastModifiedAt() {
	m.last_modified_at = nil
	m.addlast_modified_at = nil
}

// SetTitle sets the "title" field.
func (m *VulnerabilityMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *VulnerabilityMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *VulnerabilityMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[vulnerability.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *VulnerabilityMutation) TitleCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *VulnerabilityMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, vulnerability.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *VulnerabilityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VulnerabilityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VulnerabilityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vulnerability.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VulnerabilityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VulnerabilityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vulnerability.FieldDescription)
}

// SetCweID sets the "cwe_id" field.
func (m *VulnerabilityMutation) SetCweID(s []string) {
	m.cwe_id = &s
}

// CweID returns the value of the "cwe_id" field in the mutation.
func (m *VulnerabilityMutation) CweID() (r []string, exists bool) {
	v := m.cwe_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCweID returns the old "cwe_id" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldCweID(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCweID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCweID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCweID: %w", err)
	}
	return oldValue.CweID, nil
}

// ClearCweID clears the value of the "cwe_id" field.
func (m *VulnerabilityMutation) ClearCweID() {
	m.cwe_id = nil
	m.clearedFields[vulnerability.FieldCweID] = struct{}{}
}

// CweIDCleared returns if the "cwe_id" field was cleared in this mutation.
func (m *VulnerabilityMutation) CweIDCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldCweID]
	return ok
}

// ResetCweID resets all changes to the "cwe_id" field.
func (m *VulnerabilityMutation) ResetCweID() {
	m.cwe_id = nil
	delete(m.clearedFields, vulnerability.FieldCweID)
}

// SetSeverity sets the "severity" field.
func (m *VulnerabilityMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *VulnerabilityMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ClearSeverity clears the value of the "severity" field.
func (m *VulnerabilityMutation) ClearSeverity() {
	m.severity = nil
	m.clearedFields[vulnerability.FieldSeverity] = struct{}{}
}

// SeverityCleared returns if the "severity" field was cleared in this mutation.
func (m *VulnerabilityMutation) SeverityCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldSeverity]
	return ok
}

// ResetSeverity resets all changes to the "severity" field.
func (m *VulnerabilityMutation) ResetSeverity() {
	m.severity = nil
	delete(m.clearedFields, vulnerability.FieldSeverity)
}

// SetCvss sets the "cvss" field.
func (m *VulnerabilityMutation) SetCvss(s []string) {
	m.cvss = &s
}

// Cvss returns the value of the "cvss" field in the mutation.
func (m *VulnerabilityMutation) Cvss() (r []string, exists bool) {
	v := m.cvss
	if v == nil {
		return
	}
	return *v, true
}

// OldCvss returns the old "cvss" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldCvss(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCvss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCvss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCvss: %w", err)
	}
	return oldValue.Cvss, nil
}

// ClearCvss clears the value of the "cvss" field.
func (m *VulnerabilityMutation) ClearCvss() {
	m.cvss = nil
	m.clearedFields[vulnerability.FieldCvss] = struct{}{}
}

// CvssCleared returns if the "cvss" field was cleared in this mutation.
func (m *VulnerabilityMutation) CvssCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldCvss]
	return ok
}

// ResetCvss resets all changes to the "cvss" field.
func (m *VulnerabilityMutation) ResetCvss() {
	m.cvss = nil
	delete(m.clearedFields, vulnerability.FieldCvss)
}

// SetReferences sets the "references" field.
func (m *VulnerabilityMutation) SetReferences(s []string) {
	m.references = &s
}

// References returns the value of the "references" field in the mutation.
func (m *VulnerabilityMutation) References() (r []string, exists bool) {
	v := m.references
	if v == nil {
		return
	}
	return *v, true
}

// OldReferences returns the old "references" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldReferences(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferences: %w", err)
	}
	return oldValue.References, nil
}

// ClearReferences clears the value of the "references" field.
func (m *VulnerabilityMutation) ClearReferences() {
	m.references = nil
	m.clearedFields[vulnerability.FieldReferences] = struct{}{}
}

// ReferencesCleared returns if the "references" field was cleared in this mutation.
func (m *VulnerabilityMutation) ReferencesCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldReferences]
	return ok
}

// ResetReferences resets all changes to the "references" field.
func (m *VulnerabilityMutation) ResetReferences() {
	m.references = nil
	delete(m.clearedFields, vulnerability.FieldReferences)
}

// SetFixedVersion sets the "fixed_version" field.
func (m *VulnerabilityMutation) SetFixedVersion(s string) {
	m.fixed_version = &s
}

// FixedVersion returns the value of the "fixed_version" field in the mutation.
func (m *VulnerabilityMutation) FixedVersion() (r string, exists bool) {
	v := m.fixed_version
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedVersion returns the old "fixed_version" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldFixedVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFixedVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFixedVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedVersion: %w", err)
	}
	return oldValue.FixedVersion, nil
}

// ClearFixedVersion clears the value of the "fixed_version" field.
func (m *VulnerabilityMutation) ClearFixedVersion() {
	m.fixed_version = nil
	m.clearedFields[vulnerability.FieldFixedVersion] = struct{}{}
}

// FixedVersionCleared returns if the "fixed_version" field was cleared in this mutation.
func (m *VulnerabilityMutation) FixedVersionCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldFixedVersion]
	return ok
}

// ResetFixedVersion resets all changes to the "fixed_version" field.
func (m *VulnerabilityMutation) ResetFixedVersion() {
	m.fixed_version = nil
	delete(m.clearedFields, vulnerability.FieldFixedVersion)
}

// AddPackageIDs adds the "packages" edge to the PackageRecord entity by ids.
func (m *VulnerabilityMutation) AddPackageIDs(ids ...int) {
	if m.packages == nil {
		m.packages = make(map[int]struct{})
	}
	for i := range ids {
		m.packages[ids[i]] = struct{}{}
	}
}

// ClearPackages clears the "packages" edge to the PackageRecord entity.
func (m *VulnerabilityMutation) ClearPackages() {
	m.clearedpackages = true
}

// PackagesCleared reports if the "packages" edge to the PackageRecord entity was cleared.
func (m *VulnerabilityMutation) PackagesCleared() bool {
	return m.clearedpackages
}

// RemovePackageIDs removes the "packages" edge to the PackageRecord entity by IDs.
func (m *VulnerabilityMutation) RemovePackageIDs(ids ...int) {
	if m.removedpackages == nil {
		m.removedpackages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.packages, ids[i])
		m.removedpackages[ids[i]] = struct{}{}
	}
}

// RemovedPackages returns the removed IDs of the "packages" edge to the PackageRecord entity.
func (m *VulnerabilityMutation) RemovedPackagesIDs() (ids []int) {
	for id := range m.removedpackages {
		ids = append(ids, id)
	}
	return
}

// PackagesIDs returns the "packages" edge IDs in the mutation.
func (m *VulnerabilityMutation) PackagesIDs() (ids []int) {
	for id := range m.packages {
		ids = append(ids, id)
	}
	return
}

// ResetPackages resets all changes to the "packages" edge.
func (m *VulnerabilityMutation) ResetPackages() {
	m.packages = nil
	m.clearedpackages = false
	m.removedpackages = nil
}

// AddStatuIDs adds the "status" edge to the VulnStatus entity by ids.
func (m *VulnerabilityMutation) AddStatuIDs(ids ...int) {
	if m.status == nil {
		m.status = make(map[int]struct{})
	}
	for i := range ids {
		m.status[ids[i]] = struct{}{}
	}
}

// ClearStatus clears the "status" edge to the VulnStatus entity.
func (m *VulnerabilityMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared reports if the "status" edge to the VulnStatus entity was cleared.
func (m *VulnerabilityMutation) StatusCleared() bool {
	return m.clearedstatus
}

// RemoveStatuIDs removes the "status" edge to the VulnStatus entity by IDs.
func (m *VulnerabilityMutation) RemoveStatuIDs(ids ...int) {
	if m.removedstatus == nil {
		m.removedstatus = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.status, ids[i])
		m.removedstatus[ids[i]] = struct{}{}
	}
}

// RemovedStatus returns the removed IDs of the "status" edge to the VulnStatus entity.
func (m *VulnerabilityMutation) RemovedStatusIDs() (ids []int) {
	for id := range m.removedstatus {
		ids = append(ids, id)
	}
	return
}

// StatusIDs returns the "status" edge IDs in the mutation.
func (m *VulnerabilityMutation) StatusIDs() (ids []int) {
	for id := range m.status {
		ids = append(ids, id)
	}
	return
}

// ResetStatus resets all changes to the "status" edge.
func (m *VulnerabilityMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
	m.removedstatus = nil
}

// Where appends a list predicates to the VulnerabilityMutation builder.
func (m *VulnerabilityMutation) Where(ps ...predicate.Vulnerability) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VulnerabilityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vulnerability).
func (m *VulnerabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.first_seen_at != nil {
		fields = append(fields, vulnerability.FieldFirstSeenAt)
	}
	if m.last_modified_at != nil {
		fields = append(fields, vulnerability.FieldLastModifiedAt)
	}
	if m.title != nil {
		fields = append(fields, vulnerability.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, vulnerability.FieldDescription)
	}
	if m.cwe_id != nil {
		fields = append(fields, vulnerability.FieldCweID)
	}
	if m.severity != nil {
		fields = append(fields, vulnerability.FieldSeverity)
	}
	if m.cvss != nil {
		fields = append(fields, vulnerability.FieldCvss)
	}
	if m.references != nil {
		fields = append(fields, vulnerability.FieldReferences)
	}
	if m.fixed_version != nil {
		fields = append(fields, vulnerability.FieldFixedVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		return m.FirstSeenAt()
	case vulnerability.FieldLastModifiedAt:
		return m.LastModifiedAt()
	case vulnerability.FieldTitle:
		return m.Title()
	case vulnerability.FieldDescription:
		return m.Description()
	case vulnerability.FieldCweID:
		return m.CweID()
	case vulnerability.FieldSeverity:
		return m.Severity()
	case vulnerability.FieldCvss:
		return m.Cvss()
	case vulnerability.FieldReferences:
		return m.References()
	case vulnerability.FieldFixedVersion:
		return m.FixedVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		return m.OldFirstSeenAt(ctx)
	case vulnerability.FieldLastModifiedAt:
		return m.OldLastModifiedAt(ctx)
	case vulnerability.FieldTitle:
		return m.OldTitle(ctx)
	case vulnerability.FieldDescription:
		return m.OldDescription(ctx)
	case vulnerability.FieldCweID:
		return m.OldCweID(ctx)
	case vulnerability.FieldSeverity:
		return m.OldSeverity(ctx)
	case vulnerability.FieldCvss:
		return m.OldCvss(ctx)
	case vulnerability.FieldReferences:
		return m.OldReferences(ctx)
	case vulnerability.FieldFixedVersion:
		return m.OldFixedVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Vulnerability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstSeenAt(v)
		return nil
	case vulnerability.FieldLastModifiedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedAt(v)
		return nil
	case vulnerability.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case vulnerability.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case vulnerability.FieldCweID:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCweID(v)
		return nil
	case vulnerability.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case vulnerability.FieldCvss:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCvss(v)
		return nil
	case vulnerability.FieldReferences:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferences(v)
		return nil
	case vulnerability.FieldFixedVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Vulnerability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityMutation) AddedFields() []string {
	var fields []string
	if m.addfirst_seen_at != nil {
		fields = append(fields, vulnerability.FieldFirstSeenAt)
	}
	if m.addlast_modified_at != nil {
		fields = append(fields, vulnerability.FieldLastModifiedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		return m.AddedFirstSeenAt()
	case vulnerability.FieldLastModifiedAt:
		return m.AddedLastModifiedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstSeenAt(v)
		return nil
	case vulnerability.FieldLastModifiedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastModifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Vulnerability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vulnerability.FieldTitle) {
		fields = append(fields, vulnerability.FieldTitle)
	}
	if m.FieldCleared(vulnerability.FieldDescription) {
		fields = append(fields, vulnerability.FieldDescription)
	}
	if m.FieldCleared(vulnerability.FieldCweID) {
		fields = append(fields, vulnerability.FieldCweID)
	}
	if m.FieldCleared(vulnerability.FieldSeverity) {
		fields = append(fields, vulnerability.FieldSeverity)
	}
	if m.FieldCleared(vulnerability.FieldCvss) {
		fields = append(fields, vulnerability.FieldCvss)
	}
	if m.FieldCleared(vulnerability.FieldReferences) {
		fields = append(fields, vulnerability.FieldReferences)
	}
	if m.FieldCleared(vulnerability.FieldFixedVersion) {
		fields = append(fields, vulnerability.FieldFixedVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityMutation) ClearField(name string) error {
	switch name {
	case vulnerability.FieldTitle:
		m.ClearTitle()
		return nil
	case vulnerability.FieldDescription:
		m.ClearDescription()
		return nil
	case vulnerability.FieldCweID:
		m.ClearCweID()
		return nil
	case vulnerability.FieldSeverity:
		m.ClearSeverity()
		return nil
	case vulnerability.FieldCvss:
		m.ClearCvss()
		return nil
	case vulnerability.FieldReferences:
		m.ClearReferences()
		return nil
	case vulnerability.FieldFixedVersion:
		m.ClearFixedVersion()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityMutation) ResetField(name string) error {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		m.ResetFirstSeenAt()
		return nil
	case vulnerability.FieldLastModifiedAt:
		m.ResetLastModifiedAt()
		return nil
	case vulnerability.FieldTitle:
		m.ResetTitle()
		return nil
	case vulnerability.FieldDescription:
		m.ResetDescription()
		return nil
	case vulnerability.FieldCweID:
		m.ResetCweID()
		return nil
	case vulnerability.FieldSeverity:
		m.ResetSeverity()
		return nil
	case vulnerability.FieldCvss:
		m.ResetCvss()
		return nil
	case vulnerability.FieldReferences:
		m.ResetReferences()
		return nil
	case vulnerability.FieldFixedVersion:
		m.ResetFixedVersion()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.packages != nil {
		edges = append(edges, vulnerability.EdgePackages)
	}
	if m.status != nil {
		edges = append(edges, vulnerability.EdgeStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerability.EdgePackages:
		ids := make([]ent.Value, 0, len(m.packages))
		for id := range m.packages {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.status))
		for id := range m.status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpackages != nil {
		edges = append(edges, vulnerability.EdgePackages)
	}
	if m.removedstatus != nil {
		edges = append(edges, vulnerability.EdgeStatus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnerability.EdgePackages:
		ids := make([]ent.Value, 0, len(m.removedpackages))
		for id := range m.removedpackages {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.removedstatus))
		for id := range m.removedstatus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpackages {
		edges = append(edges, vulnerability.EdgePackages)
	}
	if m.clearedstatus {
		edges = append(edges, vulnerability.EdgeStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerability.EdgePackages:
		return m.clearedpackages
	case vulnerability.EdgeStatus:
		return m.clearedstatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Vulnerability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityMutation) ResetEdge(name string) error {
	switch name {
	case vulnerability.EdgePackages:
		m.ResetPackages()
		return nil
	case vulnerability.EdgeStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability edge %s", name)
}
