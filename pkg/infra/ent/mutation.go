// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/m-mizutani/octovy/pkg/domain/types"
	"github.com/m-mizutani/octovy/pkg/infra/ent/branch"
	"github.com/m-mizutani/octovy/pkg/infra/ent/packagerecord"
	"github.com/m-mizutani/octovy/pkg/infra/ent/predicate"
	"github.com/m-mizutani/octovy/pkg/infra/ent/scan"
	"github.com/m-mizutani/octovy/pkg/infra/ent/vulnerability"
	"github.com/m-mizutani/octovy/pkg/infra/ent/vulnstatus"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBranch        = "Branch"
	TypePackageRecord = "PackageRecord"
	TypeScan          = "Scan"
	TypeVulnStatus    = "VulnStatus"
	TypeVulnerability = "Vulnerability"
)

// BranchMutation represents an operation that mutates the Branch nodes in the graph.
type BranchMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	owner         *string
	repo_name     *string
	name          *string
	clearedFields map[string]struct{}
	scan          map[int]struct{}
	removedscan   map[int]struct{}
	clearedscan   bool
	done          bool
	oldValue      func(context.Context) (*Branch, error)
	predicates    []predicate.Branch
}

var _ ent.Mutation = (*BranchMutation)(nil)

// branchOption allows management of the mutation configuration using functional options.
type branchOption func(*BranchMutation)

// newBranchMutation creates new mutation for the Branch entity.
func newBranchMutation(c config, op Op, opts ...branchOption) *BranchMutation {
	m := &BranchMutation{
		config:        c,
		op:            op,
		typ:           TypeBranch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchID sets the ID field of the mutation.
func withBranchID(id int) branchOption {
	return func(m *BranchMutation) {
		var (
			err   error
			once  sync.Once
			value *Branch
		)
		m.oldValue = func(ctx context.Context) (*Branch, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Branch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranch sets the old Branch of the mutation.
func withBranch(node *Branch) branchOption {
	return func(m *BranchMutation) {
		m.oldValue = func(context.Context) (*Branch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BranchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetKey sets the "key" field.
func (m *BranchMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *BranchMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *BranchMutation) ResetKey() {
	m.key = nil
}

// SetOwner sets the "owner" field.
func (m *BranchMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *BranchMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *BranchMutation) ResetOwner() {
	m.owner = nil
}

// SetRepoName sets the "repo_name" field.
func (m *BranchMutation) SetRepoName(s string) {
	m.repo_name = &s
}

// RepoName returns the value of the "repo_name" field in the mutation.
func (m *BranchMutation) RepoName() (r string, exists bool) {
	v := m.repo_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoName returns the old "repo_name" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldRepoName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRepoName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRepoName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoName: %w", err)
	}
	return oldValue.RepoName, nil
}

// ResetRepoName resets all changes to the "repo_name" field.
func (m *BranchMutation) ResetRepoName() {
	m.repo_name = nil
}

// SetName sets the "name" field.
func (m *BranchMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BranchMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BranchMutation) ResetName() {
	m.name = nil
}

// AddScanIDs adds the "scan" edge to the Scan entity by ids.
func (m *BranchMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the Scan entity.
func (m *BranchMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the Scan entity was cleared.
func (m *BranchMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the Scan entity by IDs.
func (m *BranchMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the Scan entity.
func (m *BranchMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *BranchMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *BranchMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// Where appends a list predicates to the BranchMutation builder.
func (m *BranchMutation) Where(ps ...predicate.Branch) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BranchMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Branch).
func (m *BranchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BranchMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.key != nil {
		fields = append(fields, branch.FieldKey)
	}
	if m.owner != nil {
		fields = append(fields, branch.FieldOwner)
	}
	if m.repo_name != nil {
		fields = append(fields, branch.FieldRepoName)
	}
	if m.name != nil {
		fields = append(fields, branch.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BranchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldKey:
		return m.Key()
	case branch.FieldOwner:
		return m.Owner()
	case branch.FieldRepoName:
		return m.RepoName()
	case branch.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BranchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branch.FieldKey:
		return m.OldKey(ctx)
	case branch.FieldOwner:
		return m.OldOwner(ctx)
	case branch.FieldRepoName:
		return m.OldRepoName(ctx)
	case branch.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Branch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branch.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case branch.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case branch.FieldRepoName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoName(v)
		return nil
	case branch.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BranchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BranchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Branch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BranchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BranchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Branch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BranchMutation) ResetField(name string) error {
	switch name {
	case branch.FieldKey:
		m.ResetKey()
		return nil
	case branch.FieldOwner:
		m.ResetOwner()
		return nil
	case branch.FieldRepoName:
		m.ResetRepoName()
		return nil
	case branch.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BranchMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.scan != nil {
		edges = append(edges, branch.EdgeScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BranchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BranchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedscan != nil {
		edges = append(edges, branch.EdgeScan)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BranchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BranchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedscan {
		edges = append(edges, branch.EdgeScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BranchMutation) EdgeCleared(name string) bool {
	switch name {
	case branch.EdgeScan:
		return m.clearedscan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BranchMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Branch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BranchMutation) ResetEdge(name string) error {
	switch name {
	case branch.EdgeScan:
		m.ResetScan()
		return nil
	}
	return fmt.Errorf("unknown Branch edge %s", name)
}

// PackageRecordMutation represents an operation that mutates the PackageRecord nodes in the graph.
type PackageRecordMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_type                  *types.PkgType
	source                 *string
	name                   *string
	version                *string
	vuln_ids               *[]string
	clearedFields          map[string]struct{}
	scan                   map[int]struct{}
	removedscan            map[int]struct{}
	clearedscan            bool
	vulnerabilities        map[string]struct{}
	removedvulnerabilities map[string]struct{}
	clearedvulnerabilities bool
	status                 map[string]struct{}
	removedstatus          map[string]struct{}
	clearedstatus          bool
	done                   bool
	oldValue               func(context.Context) (*PackageRecord, error)
	predicates             []predicate.PackageRecord
}

var _ ent.Mutation = (*PackageRecordMutation)(nil)

// packagerecordOption allows management of the mutation configuration using functional options.
type packagerecordOption func(*PackageRecordMutation)

// newPackageRecordMutation creates new mutation for the PackageRecord entity.
func newPackageRecordMutation(c config, op Op, opts ...packagerecordOption) *PackageRecordMutation {
	m := &PackageRecordMutation{
		config:        c,
		op:            op,
		typ:           TypePackageRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageRecordID sets the ID field of the mutation.
func withPackageRecordID(id int) packagerecordOption {
	return func(m *PackageRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageRecord
		)
		m.oldValue = func(ctx context.Context) (*PackageRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageRecord sets the old PackageRecord of the mutation.
func withPackageRecord(node *PackageRecord) packagerecordOption {
	return func(m *PackageRecordMutation) {
		m.oldValue = func(context.Context) (*PackageRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "type" field.
func (m *PackageRecordMutation) SetType(tt types.PkgType) {
	m._type = &tt
}

// GetType returns the value of the "type" field in the mutation.
func (m *PackageRecordMutation) GetType() (r types.PkgType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PackageRecord entity.
// If the PackageRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageRecordMutation) OldType(ctx context.Context) (v types.PkgType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PackageRecordMutation) ResetType() {
	m._type = nil
}

// SetSource sets the "source" field.
func (m *PackageRecordMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *PackageRecordMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the PackageRecord entity.
// If the PackageRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageRecordMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *PackageRecordMutation) ResetSource() {
	m.source = nil
}

// SetName sets the "name" field.
func (m *PackageRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PackageRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PackageRecord entity.
// If the PackageRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PackageRecordMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PackageRecordMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PackageRecordMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PackageRecord entity.
// If the PackageRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageRecordMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PackageRecordMutation) ResetVersion() {
	m.version = nil
}

// SetVulnIds sets the "vuln_ids" field.
func (m *PackageRecordMutation) SetVulnIds(s []string) {
	m.vuln_ids = &s
}

// VulnIds returns the value of the "vuln_ids" field in the mutation.
func (m *PackageRecordMutation) VulnIds() (r []string, exists bool) {
	v := m.vuln_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnIds returns the old "vuln_ids" field's value of the PackageRecord entity.
// If the PackageRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageRecordMutation) OldVulnIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVulnIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVulnIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnIds: %w", err)
	}
	return oldValue.VulnIds, nil
}

// ResetVulnIds resets all changes to the "vuln_ids" field.
func (m *PackageRecordMutation) ResetVulnIds() {
	m.vuln_ids = nil
}

// AddScanIDs adds the "scan" edge to the Scan entity by ids.
func (m *PackageRecordMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the Scan entity.
func (m *PackageRecordMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the Scan entity was cleared.
func (m *PackageRecordMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the Scan entity by IDs.
func (m *PackageRecordMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the Scan entity.
func (m *PackageRecordMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *PackageRecordMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *PackageRecordMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the Vulnerability entity by ids.
func (m *PackageRecordMutation) AddVulnerabilityIDs(ids ...string) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[string]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the Vulnerability entity.
func (m *PackageRecordMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the Vulnerability entity was cleared.
func (m *PackageRecordMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the Vulnerability entity by IDs.
func (m *PackageRecordMutation) RemoveVulnerabilityIDs(ids ...string) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the Vulnerability entity.
func (m *PackageRecordMutation) RemovedVulnerabilitiesIDs() (ids []string) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *PackageRecordMutation) VulnerabilitiesIDs() (ids []string) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *PackageRecordMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// AddStatuIDs adds the "status" edge to the VulnStatus entity by ids.
func (m *PackageRecordMutation) AddStatuIDs(ids ...string) {
	if m.status == nil {
		m.status = make(map[string]struct{})
	}
	for i := range ids {
		m.status[ids[i]] = struct{}{}
	}
}

// ClearStatus clears the "status" edge to the VulnStatus entity.
func (m *PackageRecordMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared reports if the "status" edge to the VulnStatus entity was cleared.
func (m *PackageRecordMutation) StatusCleared() bool {
	return m.clearedstatus
}

// RemoveStatuIDs removes the "status" edge to the VulnStatus entity by IDs.
func (m *PackageRecordMutation) RemoveStatuIDs(ids ...string) {
	if m.removedstatus == nil {
		m.removedstatus = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.status, ids[i])
		m.removedstatus[ids[i]] = struct{}{}
	}
}

// RemovedStatus returns the removed IDs of the "status" edge to the VulnStatus entity.
func (m *PackageRecordMutation) RemovedStatusIDs() (ids []string) {
	for id := range m.removedstatus {
		ids = append(ids, id)
	}
	return
}

// StatusIDs returns the "status" edge IDs in the mutation.
func (m *PackageRecordMutation) StatusIDs() (ids []string) {
	for id := range m.status {
		ids = append(ids, id)
	}
	return
}

// ResetStatus resets all changes to the "status" edge.
func (m *PackageRecordMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
	m.removedstatus = nil
}

// Where appends a list predicates to the PackageRecordMutation builder.
func (m *PackageRecordMutation) Where(ps ...predicate.PackageRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PackageRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PackageRecord).
func (m *PackageRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageRecordMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, packagerecord.FieldType)
	}
	if m.source != nil {
		fields = append(fields, packagerecord.FieldSource)
	}
	if m.name != nil {
		fields = append(fields, packagerecord.FieldName)
	}
	if m.version != nil {
		fields = append(fields, packagerecord.FieldVersion)
	}
	if m.vuln_ids != nil {
		fields = append(fields, packagerecord.FieldVulnIds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagerecord.FieldType:
		return m.GetType()
	case packagerecord.FieldSource:
		return m.Source()
	case packagerecord.FieldName:
		return m.Name()
	case packagerecord.FieldVersion:
		return m.Version()
	case packagerecord.FieldVulnIds:
		return m.VulnIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagerecord.FieldType:
		return m.OldType(ctx)
	case packagerecord.FieldSource:
		return m.OldSource(ctx)
	case packagerecord.FieldName:
		return m.OldName(ctx)
	case packagerecord.FieldVersion:
		return m.OldVersion(ctx)
	case packagerecord.FieldVulnIds:
		return m.OldVulnIds(ctx)
	}
	return nil, fmt.Errorf("unknown PackageRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagerecord.FieldType:
		v, ok := value.(types.PkgType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case packagerecord.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case packagerecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case packagerecord.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case packagerecord.FieldVulnIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnIds(v)
		return nil
	}
	return fmt.Errorf("unknown PackageRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageRecordMutation) ResetField(name string) error {
	switch name {
	case packagerecord.FieldType:
		m.ResetType()
		return nil
	case packagerecord.FieldSource:
		m.ResetSource()
		return nil
	case packagerecord.FieldName:
		m.ResetName()
		return nil
	case packagerecord.FieldVersion:
		m.ResetVersion()
		return nil
	case packagerecord.FieldVulnIds:
		m.ResetVulnIds()
		return nil
	}
	return fmt.Errorf("unknown PackageRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.scan != nil {
		edges = append(edges, packagerecord.EdgeScan)
	}
	if m.vulnerabilities != nil {
		edges = append(edges, packagerecord.EdgeVulnerabilities)
	}
	if m.status != nil {
		edges = append(edges, packagerecord.EdgeStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagerecord.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	case packagerecord.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case packagerecord.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.status))
		for id := range m.status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedscan != nil {
		edges = append(edges, packagerecord.EdgeScan)
	}
	if m.removedvulnerabilities != nil {
		edges = append(edges, packagerecord.EdgeVulnerabilities)
	}
	if m.removedstatus != nil {
		edges = append(edges, packagerecord.EdgeStatus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagerecord.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	case packagerecord.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case packagerecord.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.removedstatus))
		for id := range m.removedstatus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedscan {
		edges = append(edges, packagerecord.EdgeScan)
	}
	if m.clearedvulnerabilities {
		edges = append(edges, packagerecord.EdgeVulnerabilities)
	}
	if m.clearedstatus {
		edges = append(edges, packagerecord.EdgeStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case packagerecord.EdgeScan:
		return m.clearedscan
	case packagerecord.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	case packagerecord.EdgeStatus:
		return m.clearedstatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageRecordMutation) ResetEdge(name string) error {
	switch name {
	case packagerecord.EdgeScan:
		m.ResetScan()
		return nil
	case packagerecord.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	case packagerecord.EdgeStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown PackageRecord edge %s", name)
}

// ScanMutation represents an operation that mutates the Scan nodes in the graph.
type ScanMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	commit_id           *string
	requested_at        *int64
	addrequested_at     *int64
	scanned_at          *int64
	addscanned_at       *int64
	check_id            *int64
	addcheck_id         *int64
	pull_request_target *string
	clearedFields       map[string]struct{}
	target              map[int]struct{}
	removedtarget       map[int]struct{}
	clearedtarget       bool
	packages            map[int]struct{}
	removedpackages     map[int]struct{}
	clearedpackages     bool
	done                bool
	oldValue            func(context.Context) (*Scan, error)
	predicates          []predicate.Scan
}

var _ ent.Mutation = (*ScanMutation)(nil)

// scanOption allows management of the mutation configuration using functional options.
type scanOption func(*ScanMutation)

// newScanMutation creates new mutation for the Scan entity.
func newScanMutation(c config, op Op, opts ...scanOption) *ScanMutation {
	m := &ScanMutation{
		config:        c,
		op:            op,
		typ:           TypeScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScanID sets the ID field of the mutation.
func withScanID(id int) scanOption {
	return func(m *ScanMutation) {
		var (
			err   error
			once  sync.Once
			value *Scan
		)
		m.oldValue = func(ctx context.Context) (*Scan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScan sets the old Scan of the mutation.
func withScan(node *Scan) scanOption {
	return func(m *ScanMutation) {
		m.oldValue = func(context.Context) (*Scan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCommitID sets the "commit_id" field.
func (m *ScanMutation) SetCommitID(s string) {
	m.commit_id = &s
}

// CommitID returns the value of the "commit_id" field in the mutation.
func (m *ScanMutation) CommitID() (r string, exists bool) {
	v := m.commit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitID returns the old "commit_id" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldCommitID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitID: %w", err)
	}
	return oldValue.CommitID, nil
}

// ResetCommitID resets all changes to the "commit_id" field.
func (m *ScanMutation) ResetCommitID() {
	m.commit_id = nil
}

// SetRequestedAt sets the "requested_at" field.
func (m *ScanMutation) SetRequestedAt(i int64) {
	m.requested_at = &i
	m.addrequested_at = nil
}

// RequestedAt returns the value of the "requested_at" field in the mutation.
func (m *ScanMutation) RequestedAt() (r int64, exists bool) {
	v := m.requested_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedAt returns the old "requested_at" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldRequestedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRequestedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRequestedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedAt: %w", err)
	}
	return oldValue.RequestedAt, nil
}

// AddRequestedAt adds i to the "requested_at" field.
func (m *ScanMutation) AddRequestedAt(i int64) {
	if m.addrequested_at != nil {
		*m.addrequested_at += i
	} else {
		m.addrequested_at = &i
	}
}

// AddedRequestedAt returns the value that was added to the "requested_at" field in this mutation.
func (m *ScanMutation) AddedRequestedAt() (r int64, exists bool) {
	v := m.addrequested_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequestedAt resets all changes to the "requested_at" field.
func (m *ScanMutation) ResetRequestedAt() {
	m.requested_at = nil
	m.addrequested_at = nil
}

// SetScannedAt sets the "scanned_at" field.
func (m *ScanMutation) SetScannedAt(i int64) {
	m.scanned_at = &i
	m.addscanned_at = nil
}

// ScannedAt returns the value of the "scanned_at" field in the mutation.
func (m *ScanMutation) ScannedAt() (r int64, exists bool) {
	v := m.scanned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScannedAt returns the old "scanned_at" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldScannedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScannedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScannedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScannedAt: %w", err)
	}
	return oldValue.ScannedAt, nil
}

// AddScannedAt adds i to the "scanned_at" field.
func (m *ScanMutation) AddScannedAt(i int64) {
	if m.addscanned_at != nil {
		*m.addscanned_at += i
	} else {
		m.addscanned_at = &i
	}
}

// AddedScannedAt returns the value that was added to the "scanned_at" field in this mutation.
func (m *ScanMutation) AddedScannedAt() (r int64, exists bool) {
	v := m.addscanned_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearScannedAt clears the value of the "scanned_at" field.
func (m *ScanMutation) ClearScannedAt() {
	m.scanned_at = nil
	m.addscanned_at = nil
	m.clearedFields[scan.FieldScannedAt] = struct{}{}
}

// ScannedAtCleared returns if the "scanned_at" field was cleared in this mutation.
func (m *ScanMutation) ScannedAtCleared() bool {
	_, ok := m.clearedFields[scan.FieldScannedAt]
	return ok
}

// ResetScannedAt resets all changes to the "scanned_at" field.
func (m *ScanMutation) ResetScannedAt() {
	m.scanned_at = nil
	m.addscanned_at = nil
	delete(m.clearedFields, scan.FieldScannedAt)
}

// SetCheckID sets the "check_id" field.
func (m *ScanMutation) SetCheckID(i int64) {
	m.check_id = &i
	m.addcheck_id = nil
}

// CheckID returns the value of the "check_id" field in the mutation.
func (m *ScanMutation) CheckID() (r int64, exists bool) {
	v := m.check_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckID returns the old "check_id" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldCheckID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckID: %w", err)
	}
	return oldValue.CheckID, nil
}

// AddCheckID adds i to the "check_id" field.
func (m *ScanMutation) AddCheckID(i int64) {
	if m.addcheck_id != nil {
		*m.addcheck_id += i
	} else {
		m.addcheck_id = &i
	}
}

// AddedCheckID returns the value that was added to the "check_id" field in this mutation.
func (m *ScanMutation) AddedCheckID() (r int64, exists bool) {
	v := m.addcheck_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCheckID resets all changes to the "check_id" field.
func (m *ScanMutation) ResetCheckID() {
	m.check_id = nil
	m.addcheck_id = nil
}

// SetPullRequestTarget sets the "pull_request_target" field.
func (m *ScanMutation) SetPullRequestTarget(s string) {
	m.pull_request_target = &s
}

// PullRequestTarget returns the value of the "pull_request_target" field in the mutation.
func (m *ScanMutation) PullRequestTarget() (r string, exists bool) {
	v := m.pull_request_target
	if v == nil {
		return
	}
	return *v, true
}

// OldPullRequestTarget returns the old "pull_request_target" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldPullRequestTarget(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPullRequestTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPullRequestTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullRequestTarget: %w", err)
	}
	return oldValue.PullRequestTarget, nil
}

// ClearPullRequestTarget clears the value of the "pull_request_target" field.
func (m *ScanMutation) ClearPullRequestTarget() {
	m.pull_request_target = nil
	m.clearedFields[scan.FieldPullRequestTarget] = struct{}{}
}

// PullRequestTargetCleared returns if the "pull_request_target" field was cleared in this mutation.
func (m *ScanMutation) PullRequestTargetCleared() bool {
	_, ok := m.clearedFields[scan.FieldPullRequestTarget]
	return ok
}

// ResetPullRequestTarget resets all changes to the "pull_request_target" field.
func (m *ScanMutation) ResetPullRequestTarget() {
	m.pull_request_target = nil
	delete(m.clearedFields, scan.FieldPullRequestTarget)
}

// AddTargetIDs adds the "target" edge to the Branch entity by ids.
func (m *ScanMutation) AddTargetIDs(ids ...int) {
	if m.target == nil {
		m.target = make(map[int]struct{})
	}
	for i := range ids {
		m.target[ids[i]] = struct{}{}
	}
}

// ClearTarget clears the "target" edge to the Branch entity.
func (m *ScanMutation) ClearTarget() {
	m.clearedtarget = true
}

// TargetCleared reports if the "target" edge to the Branch entity was cleared.
func (m *ScanMutation) TargetCleared() bool {
	return m.clearedtarget
}

// RemoveTargetIDs removes the "target" edge to the Branch entity by IDs.
func (m *ScanMutation) RemoveTargetIDs(ids ...int) {
	if m.removedtarget == nil {
		m.removedtarget = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.target, ids[i])
		m.removedtarget[ids[i]] = struct{}{}
	}
}

// RemovedTarget returns the removed IDs of the "target" edge to the Branch entity.
func (m *ScanMutation) RemovedTargetIDs() (ids []int) {
	for id := range m.removedtarget {
		ids = append(ids, id)
	}
	return
}

// TargetIDs returns the "target" edge IDs in the mutation.
func (m *ScanMutation) TargetIDs() (ids []int) {
	for id := range m.target {
		ids = append(ids, id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *ScanMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
	m.removedtarget = nil
}

// AddPackageIDs adds the "packages" edge to the PackageRecord entity by ids.
func (m *ScanMutation) AddPackageIDs(ids ...int) {
	if m.packages == nil {
		m.packages = make(map[int]struct{})
	}
	for i := range ids {
		m.packages[ids[i]] = struct{}{}
	}
}

// ClearPackages clears the "packages" edge to the PackageRecord entity.
func (m *ScanMutation) ClearPackages() {
	m.clearedpackages = true
}

// PackagesCleared reports if the "packages" edge to the PackageRecord entity was cleared.
func (m *ScanMutation) PackagesCleared() bool {
	return m.clearedpackages
}

// RemovePackageIDs removes the "packages" edge to the PackageRecord entity by IDs.
func (m *ScanMutation) RemovePackageIDs(ids ...int) {
	if m.removedpackages == nil {
		m.removedpackages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.packages, ids[i])
		m.removedpackages[ids[i]] = struct{}{}
	}
}

// RemovedPackages returns the removed IDs of the "packages" edge to the PackageRecord entity.
func (m *ScanMutation) RemovedPackagesIDs() (ids []int) {
	for id := range m.removedpackages {
		ids = append(ids, id)
	}
	return
}

// PackagesIDs returns the "packages" edge IDs in the mutation.
func (m *ScanMutation) PackagesIDs() (ids []int) {
	for id := range m.packages {
		ids = append(ids, id)
	}
	return
}

// ResetPackages resets all changes to the "packages" edge.
func (m *ScanMutation) ResetPackages() {
	m.packages = nil
	m.clearedpackages = false
	m.removedpackages = nil
}

// Where appends a list predicates to the ScanMutation builder.
func (m *ScanMutation) Where(ps ...predicate.Scan) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Scan).
func (m *ScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScanMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.commit_id != nil {
		fields = append(fields, scan.FieldCommitID)
	}
	if m.requested_at != nil {
		fields = append(fields, scan.FieldRequestedAt)
	}
	if m.scanned_at != nil {
		fields = append(fields, scan.FieldScannedAt)
	}
	if m.check_id != nil {
		fields = append(fields, scan.FieldCheckID)
	}
	if m.pull_request_target != nil {
		fields = append(fields, scan.FieldPullRequestTarget)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scan.FieldCommitID:
		return m.CommitID()
	case scan.FieldRequestedAt:
		return m.RequestedAt()
	case scan.FieldScannedAt:
		return m.ScannedAt()
	case scan.FieldCheckID:
		return m.CheckID()
	case scan.FieldPullRequestTarget:
		return m.PullRequestTarget()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scan.FieldCommitID:
		return m.OldCommitID(ctx)
	case scan.FieldRequestedAt:
		return m.OldRequestedAt(ctx)
	case scan.FieldScannedAt:
		return m.OldScannedAt(ctx)
	case scan.FieldCheckID:
		return m.OldCheckID(ctx)
	case scan.FieldPullRequestTarget:
		return m.OldPullRequestTarget(ctx)
	}
	return nil, fmt.Errorf("unknown Scan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scan.FieldCommitID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitID(v)
		return nil
	case scan.FieldRequestedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedAt(v)
		return nil
	case scan.FieldScannedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScannedAt(v)
		return nil
	case scan.FieldCheckID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckID(v)
		return nil
	case scan.FieldPullRequestTarget:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullRequestTarget(v)
		return nil
	}
	return fmt.Errorf("unknown Scan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScanMutation) AddedFields() []string {
	var fields []string
	if m.addrequested_at != nil {
		fields = append(fields, scan.FieldRequestedAt)
	}
	if m.addscanned_at != nil {
		fields = append(fields, scan.FieldScannedAt)
	}
	if m.addcheck_id != nil {
		fields = append(fields, scan.FieldCheckID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scan.FieldRequestedAt:
		return m.AddedRequestedAt()
	case scan.FieldScannedAt:
		return m.AddedScannedAt()
	case scan.FieldCheckID:
		return m.AddedCheckID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scan.FieldRequestedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestedAt(v)
		return nil
	case scan.FieldScannedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScannedAt(v)
		return nil
	case scan.FieldCheckID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCheckID(v)
		return nil
	}
	return fmt.Errorf("unknown Scan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scan.FieldScannedAt) {
		fields = append(fields, scan.FieldScannedAt)
	}
	if m.FieldCleared(scan.FieldPullRequestTarget) {
		fields = append(fields, scan.FieldPullRequestTarget)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScanMutation) ClearField(name string) error {
	switch name {
	case scan.FieldScannedAt:
		m.ClearScannedAt()
		return nil
	case scan.FieldPullRequestTarget:
		m.ClearPullRequestTarget()
		return nil
	}
	return fmt.Errorf("unknown Scan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScanMutation) ResetField(name string) error {
	switch name {
	case scan.FieldCommitID:
		m.ResetCommitID()
		return nil
	case scan.FieldRequestedAt:
		m.ResetRequestedAt()
		return nil
	case scan.FieldScannedAt:
		m.ResetScannedAt()
		return nil
	case scan.FieldCheckID:
		m.ResetCheckID()
		return nil
	case scan.FieldPullRequestTarget:
		m.ResetPullRequestTarget()
		return nil
	}
	return fmt.Errorf("unknown Scan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.target != nil {
		edges = append(edges, scan.EdgeTarget)
	}
	if m.packages != nil {
		edges = append(edges, scan.EdgePackages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scan.EdgeTarget:
		ids := make([]ent.Value, 0, len(m.target))
		for id := range m.target {
			ids = append(ids, id)
		}
		return ids
	case scan.EdgePackages:
		ids := make([]ent.Value, 0, len(m.packages))
		for id := range m.packages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtarget != nil {
		edges = append(edges, scan.EdgeTarget)
	}
	if m.removedpackages != nil {
		edges = append(edges, scan.EdgePackages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scan.EdgeTarget:
		ids := make([]ent.Value, 0, len(m.removedtarget))
		for id := range m.removedtarget {
			ids = append(ids, id)
		}
		return ids
	case scan.EdgePackages:
		ids := make([]ent.Value, 0, len(m.removedpackages))
		for id := range m.removedpackages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtarget {
		edges = append(edges, scan.EdgeTarget)
	}
	if m.clearedpackages {
		edges = append(edges, scan.EdgePackages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScanMutation) EdgeCleared(name string) bool {
	switch name {
	case scan.EdgeTarget:
		return m.clearedtarget
	case scan.EdgePackages:
		return m.clearedpackages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Scan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScanMutation) ResetEdge(name string) error {
	switch name {
	case scan.EdgeTarget:
		m.ResetTarget()
		return nil
	case scan.EdgePackages:
		m.ResetPackages()
		return nil
	}
	return fmt.Errorf("unknown Scan edge %s", name)
}

// VulnStatusMutation represents an operation that mutates the VulnStatus nodes in the graph.
type VulnStatusMutation struct {
	config
	op            Op
	typ           string
	id            *string
	status        *types.VulnStatusType
	vuln_id       *string
	expires_at    *int64
	addexpires_at *int64
	created_at    *int64
	addcreated_at *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VulnStatus, error)
	predicates    []predicate.VulnStatus
}

var _ ent.Mutation = (*VulnStatusMutation)(nil)

// vulnstatusOption allows management of the mutation configuration using functional options.
type vulnstatusOption func(*VulnStatusMutation)

// newVulnStatusMutation creates new mutation for the VulnStatus entity.
func newVulnStatusMutation(c config, op Op, opts ...vulnstatusOption) *VulnStatusMutation {
	m := &VulnStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnStatusID sets the ID field of the mutation.
func withVulnStatusID(id string) vulnstatusOption {
	return func(m *VulnStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnStatus
		)
		m.oldValue = func(ctx context.Context) (*VulnStatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnStatus sets the old VulnStatus of the mutation.
func withVulnStatus(node *VulnStatus) vulnstatusOption {
	return func(m *VulnStatusMutation) {
		m.oldValue = func(context.Context) (*VulnStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VulnStatus entities.
func (m *VulnStatusMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnStatusMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the "status" field.
func (m *VulnStatusMutation) SetStatus(tst types.VulnStatusType) {
	m.status = &tst
}

// Status returns the value of the "status" field in the mutation.
func (m *VulnStatusMutation) Status() (r types.VulnStatusType, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldStatus(ctx context.Context) (v types.VulnStatusType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VulnStatusMutation) ResetStatus() {
	m.status = nil
}

// SetVulnID sets the "vuln_id" field.
func (m *VulnStatusMutation) SetVulnID(s string) {
	m.vuln_id = &s
}

// VulnID returns the value of the "vuln_id" field in the mutation.
func (m *VulnStatusMutation) VulnID() (r string, exists bool) {
	v := m.vuln_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnID returns the old "vuln_id" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldVulnID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVulnID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVulnID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnID: %w", err)
	}
	return oldValue.VulnID, nil
}

// ResetVulnID resets all changes to the "vuln_id" field.
func (m *VulnStatusMutation) ResetVulnID() {
	m.vuln_id = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *VulnStatusMutation) SetExpiresAt(i int64) {
	m.expires_at = &i
	m.addexpires_at = nil
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *VulnStatusMutation) ExpiresAt() (r int64, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldExpiresAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// AddExpiresAt adds i to the "expires_at" field.
func (m *VulnStatusMutation) AddExpiresAt(i int64) {
	if m.addexpires_at != nil {
		*m.addexpires_at += i
	} else {
		m.addexpires_at = &i
	}
}

// AddedExpiresAt returns the value that was added to the "expires_at" field in this mutation.
func (m *VulnStatusMutation) AddedExpiresAt() (r int64, exists bool) {
	v := m.addexpires_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *VulnStatusMutation) ResetExpiresAt() {
	m.expires_at = nil
	m.addexpires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VulnStatusMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VulnStatusMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VulnStatus entity.
// If the VulnStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnStatusMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *VulnStatusMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *VulnStatusMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VulnStatusMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// Where appends a list predicates to the VulnStatusMutation builder.
func (m *VulnStatusMutation) Where(ps ...predicate.VulnStatus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VulnStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VulnStatus).
func (m *VulnStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnStatusMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.status != nil {
		fields = append(fields, vulnstatus.FieldStatus)
	}
	if m.vuln_id != nil {
		fields = append(fields, vulnstatus.FieldVulnID)
	}
	if m.expires_at != nil {
		fields = append(fields, vulnstatus.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, vulnstatus.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnstatus.FieldStatus:
		return m.Status()
	case vulnstatus.FieldVulnID:
		return m.VulnID()
	case vulnstatus.FieldExpiresAt:
		return m.ExpiresAt()
	case vulnstatus.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnstatus.FieldStatus:
		return m.OldStatus(ctx)
	case vulnstatus.FieldVulnID:
		return m.OldVulnID(ctx)
	case vulnstatus.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case vulnstatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VulnStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnstatus.FieldStatus:
		v, ok := value.(types.VulnStatusType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case vulnstatus.FieldVulnID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnID(v)
		return nil
	case vulnstatus.FieldExpiresAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case vulnstatus.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VulnStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnStatusMutation) AddedFields() []string {
	var fields []string
	if m.addexpires_at != nil {
		fields = append(fields, vulnstatus.FieldExpiresAt)
	}
	if m.addcreated_at != nil {
		fields = append(fields, vulnstatus.FieldCreatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vulnstatus.FieldExpiresAt:
		return m.AddedExpiresAt()
	case vulnstatus.FieldCreatedAt:
		return m.AddedCreatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vulnstatus.FieldExpiresAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiresAt(v)
		return nil
	case vulnstatus.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VulnStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VulnStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnStatusMutation) ResetField(name string) error {
	switch name {
	case vulnstatus.FieldStatus:
		m.ResetStatus()
		return nil
	case vulnstatus.FieldVulnID:
		m.ResetVulnID()
		return nil
	case vulnstatus.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case vulnstatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown VulnStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnStatusMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnStatusMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnStatusMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VulnStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnStatusMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VulnStatus edge %s", name)
}

// VulnerabilityMutation represents an operation that mutates the Vulnerability nodes in the graph.
type VulnerabilityMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	first_seen_at       *int64
	addfirst_seen_at    *int64
	last_modified_at    *int64
	addlast_modified_at *int64
	title               *string
	description         *string
	cwe_id              *[]string
	severity            *string
	cvss                *[]string
	references          *[]string
	clearedFields       map[string]struct{}
	packages            map[int]struct{}
	removedpackages     map[int]struct{}
	clearedpackages     bool
	status              map[string]struct{}
	removedstatus       map[string]struct{}
	clearedstatus       bool
	done                bool
	oldValue            func(context.Context) (*Vulnerability, error)
	predicates          []predicate.Vulnerability
}

var _ ent.Mutation = (*VulnerabilityMutation)(nil)

// vulnerabilityOption allows management of the mutation configuration using functional options.
type vulnerabilityOption func(*VulnerabilityMutation)

// newVulnerabilityMutation creates new mutation for the Vulnerability entity.
func newVulnerabilityMutation(c config, op Op, opts ...vulnerabilityOption) *VulnerabilityMutation {
	m := &VulnerabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityID sets the ID field of the mutation.
func withVulnerabilityID(id string) vulnerabilityOption {
	return func(m *VulnerabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Vulnerability
		)
		m.oldValue = func(ctx context.Context) (*Vulnerability, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vulnerability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerability sets the old Vulnerability of the mutation.
func withVulnerability(node *Vulnerability) vulnerabilityOption {
	return func(m *VulnerabilityMutation) {
		m.oldValue = func(context.Context) (*Vulnerability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vulnerability entities.
func (m *VulnerabilityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFirstSeenAt sets the "first_seen_at" field.
func (m *VulnerabilityMutation) SetFirstSeenAt(i int64) {
	m.first_seen_at = &i
	m.addfirst_seen_at = nil
}

// FirstSeenAt returns the value of the "first_seen_at" field in the mutation.
func (m *VulnerabilityMutation) FirstSeenAt() (r int64, exists bool) {
	v := m.first_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstSeenAt returns the old "first_seen_at" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldFirstSeenAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstSeenAt: %w", err)
	}
	return oldValue.FirstSeenAt, nil
}

// AddFirstSeenAt adds i to the "first_seen_at" field.
func (m *VulnerabilityMutation) AddFirstSeenAt(i int64) {
	if m.addfirst_seen_at != nil {
		*m.addfirst_seen_at += i
	} else {
		m.addfirst_seen_at = &i
	}
}

// AddedFirstSeenAt returns the value that was added to the "first_seen_at" field in this mutation.
func (m *VulnerabilityMutation) AddedFirstSeenAt() (r int64, exists bool) {
	v := m.addfirst_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstSeenAt resets all changes to the "first_seen_at" field.
func (m *VulnerabilityMutation) ResetFirstSeenAt() {
	m.first_seen_at = nil
	m.addfirst_seen_at = nil
}

// SetLastModifiedAt sets the "last_modified_at" field.
func (m *VulnerabilityMutation) SetLastModifiedAt(i int64) {
	m.last_modified_at = &i
	m.addlast_modified_at = nil
}

// LastModifiedAt returns the value of the "last_modified_at" field in the mutation.
func (m *VulnerabilityMutation) LastModifiedAt() (r int64, exists bool) {
	v := m.last_modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedAt returns the old "last_modified_at" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldLastModifiedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedAt: %w", err)
	}
	return oldValue.LastModifiedAt, nil
}

// AddLastModifiedAt adds i to the "last_modified_at" field.
func (m *VulnerabilityMutation) AddLastModifiedAt(i int64) {
	if m.addlast_modified_at != nil {
		*m.addlast_modified_at += i
	} else {
		m.addlast_modified_at = &i
	}
}

// AddedLastModifiedAt returns the value that was added to the "last_modified_at" field in this mutation.
func (m *VulnerabilityMutation) AddedLastModifiedAt() (r int64, exists bool) {
	v := m.addlast_modified_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastModifiedAt resets all changes to the "last_modified_at" field.
func (m *VulnerabilityMutation) ResetLastModifiedAt() {
	m.last_modified_at = nil
	m.addlast_modified_at = nil
}

// SetTitle sets the "title" field.
func (m *VulnerabilityMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *VulnerabilityMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *VulnerabilityMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[vulnerability.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *VulnerabilityMutation) TitleCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *VulnerabilityMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, vulnerability.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *VulnerabilityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VulnerabilityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VulnerabilityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vulnerability.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VulnerabilityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VulnerabilityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vulnerability.FieldDescription)
}

// SetCweID sets the "cwe_id" field.
func (m *VulnerabilityMutation) SetCweID(s []string) {
	m.cwe_id = &s
}

// CweID returns the value of the "cwe_id" field in the mutation.
func (m *VulnerabilityMutation) CweID() (r []string, exists bool) {
	v := m.cwe_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCweID returns the old "cwe_id" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldCweID(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCweID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCweID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCweID: %w", err)
	}
	return oldValue.CweID, nil
}

// ClearCweID clears the value of the "cwe_id" field.
func (m *VulnerabilityMutation) ClearCweID() {
	m.cwe_id = nil
	m.clearedFields[vulnerability.FieldCweID] = struct{}{}
}

// CweIDCleared returns if the "cwe_id" field was cleared in this mutation.
func (m *VulnerabilityMutation) CweIDCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldCweID]
	return ok
}

// ResetCweID resets all changes to the "cwe_id" field.
func (m *VulnerabilityMutation) ResetCweID() {
	m.cwe_id = nil
	delete(m.clearedFields, vulnerability.FieldCweID)
}

// SetSeverity sets the "severity" field.
func (m *VulnerabilityMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *VulnerabilityMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ClearSeverity clears the value of the "severity" field.
func (m *VulnerabilityMutation) ClearSeverity() {
	m.severity = nil
	m.clearedFields[vulnerability.FieldSeverity] = struct{}{}
}

// SeverityCleared returns if the "severity" field was cleared in this mutation.
func (m *VulnerabilityMutation) SeverityCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldSeverity]
	return ok
}

// ResetSeverity resets all changes to the "severity" field.
func (m *VulnerabilityMutation) ResetSeverity() {
	m.severity = nil
	delete(m.clearedFields, vulnerability.FieldSeverity)
}

// SetCvss sets the "cvss" field.
func (m *VulnerabilityMutation) SetCvss(s []string) {
	m.cvss = &s
}

// Cvss returns the value of the "cvss" field in the mutation.
func (m *VulnerabilityMutation) Cvss() (r []string, exists bool) {
	v := m.cvss
	if v == nil {
		return
	}
	return *v, true
}

// OldCvss returns the old "cvss" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldCvss(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCvss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCvss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCvss: %w", err)
	}
	return oldValue.Cvss, nil
}

// ClearCvss clears the value of the "cvss" field.
func (m *VulnerabilityMutation) ClearCvss() {
	m.cvss = nil
	m.clearedFields[vulnerability.FieldCvss] = struct{}{}
}

// CvssCleared returns if the "cvss" field was cleared in this mutation.
func (m *VulnerabilityMutation) CvssCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldCvss]
	return ok
}

// ResetCvss resets all changes to the "cvss" field.
func (m *VulnerabilityMutation) ResetCvss() {
	m.cvss = nil
	delete(m.clearedFields, vulnerability.FieldCvss)
}

// SetReferences sets the "references" field.
func (m *VulnerabilityMutation) SetReferences(s []string) {
	m.references = &s
}

// References returns the value of the "references" field in the mutation.
func (m *VulnerabilityMutation) References() (r []string, exists bool) {
	v := m.references
	if v == nil {
		return
	}
	return *v, true
}

// OldReferences returns the old "references" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldReferences(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferences: %w", err)
	}
	return oldValue.References, nil
}

// ClearReferences clears the value of the "references" field.
func (m *VulnerabilityMutation) ClearReferences() {
	m.references = nil
	m.clearedFields[vulnerability.FieldReferences] = struct{}{}
}

// ReferencesCleared returns if the "references" field was cleared in this mutation.
func (m *VulnerabilityMutation) ReferencesCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldReferences]
	return ok
}

// ResetReferences resets all changes to the "references" field.
func (m *VulnerabilityMutation) ResetReferences() {
	m.references = nil
	delete(m.clearedFields, vulnerability.FieldReferences)
}

// AddPackageIDs adds the "packages" edge to the PackageRecord entity by ids.
func (m *VulnerabilityMutation) AddPackageIDs(ids ...int) {
	if m.packages == nil {
		m.packages = make(map[int]struct{})
	}
	for i := range ids {
		m.packages[ids[i]] = struct{}{}
	}
}

// ClearPackages clears the "packages" edge to the PackageRecord entity.
func (m *VulnerabilityMutation) ClearPackages() {
	m.clearedpackages = true
}

// PackagesCleared reports if the "packages" edge to the PackageRecord entity was cleared.
func (m *VulnerabilityMutation) PackagesCleared() bool {
	return m.clearedpackages
}

// RemovePackageIDs removes the "packages" edge to the PackageRecord entity by IDs.
func (m *VulnerabilityMutation) RemovePackageIDs(ids ...int) {
	if m.removedpackages == nil {
		m.removedpackages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.packages, ids[i])
		m.removedpackages[ids[i]] = struct{}{}
	}
}

// RemovedPackages returns the removed IDs of the "packages" edge to the PackageRecord entity.
func (m *VulnerabilityMutation) RemovedPackagesIDs() (ids []int) {
	for id := range m.removedpackages {
		ids = append(ids, id)
	}
	return
}

// PackagesIDs returns the "packages" edge IDs in the mutation.
func (m *VulnerabilityMutation) PackagesIDs() (ids []int) {
	for id := range m.packages {
		ids = append(ids, id)
	}
	return
}

// ResetPackages resets all changes to the "packages" edge.
func (m *VulnerabilityMutation) ResetPackages() {
	m.packages = nil
	m.clearedpackages = false
	m.removedpackages = nil
}

// AddStatuIDs adds the "status" edge to the VulnStatus entity by ids.
func (m *VulnerabilityMutation) AddStatuIDs(ids ...string) {
	if m.status == nil {
		m.status = make(map[string]struct{})
	}
	for i := range ids {
		m.status[ids[i]] = struct{}{}
	}
}

// ClearStatus clears the "status" edge to the VulnStatus entity.
func (m *VulnerabilityMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared reports if the "status" edge to the VulnStatus entity was cleared.
func (m *VulnerabilityMutation) StatusCleared() bool {
	return m.clearedstatus
}

// RemoveStatuIDs removes the "status" edge to the VulnStatus entity by IDs.
func (m *VulnerabilityMutation) RemoveStatuIDs(ids ...string) {
	if m.removedstatus == nil {
		m.removedstatus = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.status, ids[i])
		m.removedstatus[ids[i]] = struct{}{}
	}
}

// RemovedStatus returns the removed IDs of the "status" edge to the VulnStatus entity.
func (m *VulnerabilityMutation) RemovedStatusIDs() (ids []string) {
	for id := range m.removedstatus {
		ids = append(ids, id)
	}
	return
}

// StatusIDs returns the "status" edge IDs in the mutation.
func (m *VulnerabilityMutation) StatusIDs() (ids []string) {
	for id := range m.status {
		ids = append(ids, id)
	}
	return
}

// ResetStatus resets all changes to the "status" edge.
func (m *VulnerabilityMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
	m.removedstatus = nil
}

// Where appends a list predicates to the VulnerabilityMutation builder.
func (m *VulnerabilityMutation) Where(ps ...predicate.Vulnerability) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VulnerabilityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vulnerability).
func (m *VulnerabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.first_seen_at != nil {
		fields = append(fields, vulnerability.FieldFirstSeenAt)
	}
	if m.last_modified_at != nil {
		fields = append(fields, vulnerability.FieldLastModifiedAt)
	}
	if m.title != nil {
		fields = append(fields, vulnerability.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, vulnerability.FieldDescription)
	}
	if m.cwe_id != nil {
		fields = append(fields, vulnerability.FieldCweID)
	}
	if m.severity != nil {
		fields = append(fields, vulnerability.FieldSeverity)
	}
	if m.cvss != nil {
		fields = append(fields, vulnerability.FieldCvss)
	}
	if m.references != nil {
		fields = append(fields, vulnerability.FieldReferences)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		return m.FirstSeenAt()
	case vulnerability.FieldLastModifiedAt:
		return m.LastModifiedAt()
	case vulnerability.FieldTitle:
		return m.Title()
	case vulnerability.FieldDescription:
		return m.Description()
	case vulnerability.FieldCweID:
		return m.CweID()
	case vulnerability.FieldSeverity:
		return m.Severity()
	case vulnerability.FieldCvss:
		return m.Cvss()
	case vulnerability.FieldReferences:
		return m.References()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		return m.OldFirstSeenAt(ctx)
	case vulnerability.FieldLastModifiedAt:
		return m.OldLastModifiedAt(ctx)
	case vulnerability.FieldTitle:
		return m.OldTitle(ctx)
	case vulnerability.FieldDescription:
		return m.OldDescription(ctx)
	case vulnerability.FieldCweID:
		return m.OldCweID(ctx)
	case vulnerability.FieldSeverity:
		return m.OldSeverity(ctx)
	case vulnerability.FieldCvss:
		return m.OldCvss(ctx)
	case vulnerability.FieldReferences:
		return m.OldReferences(ctx)
	}
	return nil, fmt.Errorf("unknown Vulnerability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstSeenAt(v)
		return nil
	case vulnerability.FieldLastModifiedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedAt(v)
		return nil
	case vulnerability.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case vulnerability.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case vulnerability.FieldCweID:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCweID(v)
		return nil
	case vulnerability.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case vulnerability.FieldCvss:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCvss(v)
		return nil
	case vulnerability.FieldReferences:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferences(v)
		return nil
	}
	return fmt.Errorf("unknown Vulnerability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityMutation) AddedFields() []string {
	var fields []string
	if m.addfirst_seen_at != nil {
		fields = append(fields, vulnerability.FieldFirstSeenAt)
	}
	if m.addlast_modified_at != nil {
		fields = append(fields, vulnerability.FieldLastModifiedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		return m.AddedFirstSeenAt()
	case vulnerability.FieldLastModifiedAt:
		return m.AddedLastModifiedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstSeenAt(v)
		return nil
	case vulnerability.FieldLastModifiedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastModifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Vulnerability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vulnerability.FieldTitle) {
		fields = append(fields, vulnerability.FieldTitle)
	}
	if m.FieldCleared(vulnerability.FieldDescription) {
		fields = append(fields, vulnerability.FieldDescription)
	}
	if m.FieldCleared(vulnerability.FieldCweID) {
		fields = append(fields, vulnerability.FieldCweID)
	}
	if m.FieldCleared(vulnerability.FieldSeverity) {
		fields = append(fields, vulnerability.FieldSeverity)
	}
	if m.FieldCleared(vulnerability.FieldCvss) {
		fields = append(fields, vulnerability.FieldCvss)
	}
	if m.FieldCleared(vulnerability.FieldReferences) {
		fields = append(fields, vulnerability.FieldReferences)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityMutation) ClearField(name string) error {
	switch name {
	case vulnerability.FieldTitle:
		m.ClearTitle()
		return nil
	case vulnerability.FieldDescription:
		m.ClearDescription()
		return nil
	case vulnerability.FieldCweID:
		m.ClearCweID()
		return nil
	case vulnerability.FieldSeverity:
		m.ClearSeverity()
		return nil
	case vulnerability.FieldCvss:
		m.ClearCvss()
		return nil
	case vulnerability.FieldReferences:
		m.ClearReferences()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityMutation) ResetField(name string) error {
	switch name {
	case vulnerability.FieldFirstSeenAt:
		m.ResetFirstSeenAt()
		return nil
	case vulnerability.FieldLastModifiedAt:
		m.ResetLastModifiedAt()
		return nil
	case vulnerability.FieldTitle:
		m.ResetTitle()
		return nil
	case vulnerability.FieldDescription:
		m.ResetDescription()
		return nil
	case vulnerability.FieldCweID:
		m.ResetCweID()
		return nil
	case vulnerability.FieldSeverity:
		m.ResetSeverity()
		return nil
	case vulnerability.FieldCvss:
		m.ResetCvss()
		return nil
	case vulnerability.FieldReferences:
		m.ResetReferences()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.packages != nil {
		edges = append(edges, vulnerability.EdgePackages)
	}
	if m.status != nil {
		edges = append(edges, vulnerability.EdgeStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerability.EdgePackages:
		ids := make([]ent.Value, 0, len(m.packages))
		for id := range m.packages {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.status))
		for id := range m.status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpackages != nil {
		edges = append(edges, vulnerability.EdgePackages)
	}
	if m.removedstatus != nil {
		edges = append(edges, vulnerability.EdgeStatus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnerability.EdgePackages:
		ids := make([]ent.Value, 0, len(m.removedpackages))
		for id := range m.removedpackages {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.removedstatus))
		for id := range m.removedstatus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpackages {
		edges = append(edges, vulnerability.EdgePackages)
	}
	if m.clearedstatus {
		edges = append(edges, vulnerability.EdgeStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerability.EdgePackages:
		return m.clearedpackages
	case vulnerability.EdgeStatus:
		return m.clearedstatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Vulnerability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityMutation) ResetEdge(name string) error {
	switch name {
	case vulnerability.EdgePackages:
		m.ResetPackages()
		return nil
	case vulnerability.EdgeStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability edge %s", name)
}
