// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: query.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const getLatestResultsByCommit = `-- name: GetLatestResultsByCommit :many
SELECT results.id, results.scan_id, results.target, results.target_type, results.class FROM results
INNER JOIN (
    SELECT scans.id AS id FROM meta_github_repository
    INNER JOIN scans ON scans.id = meta_github_repository.scan_id
    INNER JOIN github_repository ON github_repository.id = meta_github_repository.repository_id
    WHERE meta_github_repository.commit_id = $1
    AND github_repository.repo_id = $2
    ORDER BY scans.created_at DESC
    LIMIT 1
) AS latest_scan ON latest_scan.id = results.scan_id
`

type GetLatestResultsByCommitParams struct {
	CommitID string
	RepoID   int64
}

func (q *Queries) GetLatestResultsByCommit(ctx context.Context, arg GetLatestResultsByCommitParams) ([]Result, error) {
	rows, err := q.db.QueryContext(ctx, getLatestResultsByCommit, arg.CommitID, arg.RepoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Result
	for rows.Next() {
		var i Result
		if err := rows.Scan(
			&i.ID,
			&i.ScanID,
			&i.Target,
			&i.TargetType,
			&i.Class,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPackages = `-- name: GetPackages :many
SELECT id, target_type, name, version FROM packages WHERE id = ANY($1::text[])
`

func (q *Queries) GetPackages(ctx context.Context, dollar_1 []string) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, getPackages, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.TargetType,
			&i.Name,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVulnerabilities = `-- name: GetVulnerabilities :many
SELECT id, title, severity, published_at, last_modified_at, data, page_seq FROM vulnerabilities WHERE id = ANY($1::text[])
`

func (q *Queries) GetVulnerabilities(ctx context.Context, dollar_1 []string) ([]Vulnerability, error) {
	rows, err := q.db.QueryContext(ctx, getVulnerabilities, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vulnerability
	for rows.Next() {
		var i Vulnerability
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Severity,
			&i.PublishedAt,
			&i.LastModifiedAt,
			&i.Data,
			&i.PageSeq,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVulnerabilitiesByResultID = `-- name: GetVulnerabilitiesByResultID :many
SELECT detected_vulnerabilities.id, detected_vulnerabilities.result_id, detected_vulnerabilities.vuln_id, detected_vulnerabilities.pkg_id, detected_vulnerabilities.fixed_version, detected_vulnerabilities.installed_version, detected_vulnerabilities.data FROM detected_vulnerabilities
WHERE detected_vulnerabilities.result_id = $1
`

func (q *Queries) GetVulnerabilitiesByResultID(ctx context.Context, resultID uuid.UUID) ([]DetectedVulnerability, error) {
	rows, err := q.db.QueryContext(ctx, getVulnerabilitiesByResultID, resultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DetectedVulnerability
	for rows.Next() {
		var i DetectedVulnerability
		if err := rows.Scan(
			&i.ID,
			&i.ResultID,
			&i.VulnID,
			&i.PkgID,
			&i.FixedVersion,
			&i.InstalledVersion,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVulnerability = `-- name: GetVulnerability :one
SELECT id, title, severity, published_at, last_modified_at, data, page_seq FROM vulnerabilities WHERE id = $1
`

func (q *Queries) GetVulnerability(ctx context.Context, id string) (Vulnerability, error) {
	row := q.db.QueryRowContext(ctx, getVulnerability, id)
	var i Vulnerability
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Severity,
		&i.PublishedAt,
		&i.LastModifiedAt,
		&i.Data,
		&i.PageSeq,
	)
	return i, err
}

const saveDetectedPackage = `-- name: SaveDetectedPackage :exec
INSERT INTO detected_packages (
    id,
    result_id,
    pkg_id
) VALUES (
    $1, $2, $3
)
`

type SaveDetectedPackageParams struct {
	ID       uuid.UUID
	ResultID uuid.UUID
	PkgID    string
}

func (q *Queries) SaveDetectedPackage(ctx context.Context, arg SaveDetectedPackageParams) error {
	_, err := q.db.ExecContext(ctx, saveDetectedPackage, arg.ID, arg.ResultID, arg.PkgID)
	return err
}

const saveDetectedVulnerability = `-- name: SaveDetectedVulnerability :exec
INSERT INTO detected_vulnerabilities (
    id,
    result_id,
    vuln_id,
    pkg_id,
    installed_version,
    fixed_version,
    data
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type SaveDetectedVulnerabilityParams struct {
	ID               uuid.UUID
	ResultID         uuid.UUID
	VulnID           string
	PkgID            string
	InstalledVersion sql.NullString
	FixedVersion     sql.NullString
	Data             pqtype.NullRawMessage
}

func (q *Queries) SaveDetectedVulnerability(ctx context.Context, arg SaveDetectedVulnerabilityParams) error {
	_, err := q.db.ExecContext(ctx, saveDetectedVulnerability,
		arg.ID,
		arg.ResultID,
		arg.VulnID,
		arg.PkgID,
		arg.InstalledVersion,
		arg.FixedVersion,
		arg.Data,
	)
	return err
}

const saveGithubRepository = `-- name: SaveGithubRepository :one
WITH ins AS (
    INSERT INTO github_repository (
        id,
        repo_id,
        owner,
        repo_name
    ) VALUES (
        $1, $2, $3, $4
    ) ON CONFLICT (repo_id) DO NOTHING
    RETURNING id
)
SELECT id FROM ins
UNION ALL
SELECT id FROM github_repository WHERE repo_id = $2 AND NOT EXISTS (SELECT 1 FROM ins)
`

type SaveGithubRepositoryParams struct {
	ID       uuid.UUID
	RepoID   int64
	Owner    string
	RepoName string
}

func (q *Queries) SaveGithubRepository(ctx context.Context, arg SaveGithubRepositoryParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, saveGithubRepository,
		arg.ID,
		arg.RepoID,
		arg.Owner,
		arg.RepoName,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const saveMetaGithubRepository = `-- name: SaveMetaGithubRepository :exec
INSERT INTO meta_github_repository (
    id,
    scan_id,
    repository_id,
    branch,
    is_default_branch,
    commit_id,
    base_commit_id,
    pull_request_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
`

type SaveMetaGithubRepositoryParams struct {
	ID              uuid.UUID
	ScanID          uuid.UUID
	RepositoryID    uuid.UUID
	Branch          sql.NullString
	IsDefaultBranch sql.NullBool
	CommitID        string
	BaseCommitID    sql.NullString
	PullRequestID   sql.NullInt32
}

func (q *Queries) SaveMetaGithubRepository(ctx context.Context, arg SaveMetaGithubRepositoryParams) error {
	_, err := q.db.ExecContext(ctx, saveMetaGithubRepository,
		arg.ID,
		arg.ScanID,
		arg.RepositoryID,
		arg.Branch,
		arg.IsDefaultBranch,
		arg.CommitID,
		arg.BaseCommitID,
		arg.PullRequestID,
	)
	return err
}

const savePackage = `-- name: SavePackage :exec
INSERT INTO packages (
    id,
    target_type,
    name,
    version
) VALUES (
    $1, $2, $3, $4
)
`

type SavePackageParams struct {
	ID         string
	TargetType string
	Name       string
	Version    string
}

func (q *Queries) SavePackage(ctx context.Context, arg SavePackageParams) error {
	_, err := q.db.ExecContext(ctx, savePackage,
		arg.ID,
		arg.TargetType,
		arg.Name,
		arg.Version,
	)
	return err
}

const saveResult = `-- name: SaveResult :exec
INSERT INTO results (
    id,
    scan_id,
    target,
    target_type,
    class
) VALUES (
    $1, $2, $3, $4, $5
)
`

type SaveResultParams struct {
	ID         uuid.UUID
	ScanID     uuid.UUID
	Target     string
	TargetType string
	Class      TargetClass
}

func (q *Queries) SaveResult(ctx context.Context, arg SaveResultParams) error {
	_, err := q.db.ExecContext(ctx, saveResult,
		arg.ID,
		arg.ScanID,
		arg.Target,
		arg.TargetType,
		arg.Class,
	)
	return err
}

const saveScan = `-- name: SaveScan :exec
INSERT INTO scans (
    id,
    artifact_name,
    artifact_type
) VALUES (
    $1, $2, $3
)
`

type SaveScanParams struct {
	ID           uuid.UUID
	ArtifactName string
	ArtifactType string
}

func (q *Queries) SaveScan(ctx context.Context, arg SaveScanParams) error {
	_, err := q.db.ExecContext(ctx, saveScan, arg.ID, arg.ArtifactName, arg.ArtifactType)
	return err
}

const saveVulnerability = `-- name: SaveVulnerability :exec
INSERT INTO vulnerabilities (
    id,
    title,
    severity,
    published_at,
    last_modified_at,
    data
) VALUES (
    $1, $2, $3, $4, $5, $6
) ON CONFLICT (id)
DO UPDATE SET
    title = $2,
    severity = $3,
    published_at = $4,
    last_modified_at = $5,
    data = $6
WHERE vulnerabilities.last_modified_at < $5
`

type SaveVulnerabilityParams struct {
	ID             string
	Title          string
	Severity       string
	PublishedAt    sql.NullTime
	LastModifiedAt sql.NullTime
	Data           pqtype.NullRawMessage
}

func (q *Queries) SaveVulnerability(ctx context.Context, arg SaveVulnerabilityParams) error {
	_, err := q.db.ExecContext(ctx, saveVulnerability,
		arg.ID,
		arg.Title,
		arg.Severity,
		arg.PublishedAt,
		arg.LastModifiedAt,
		arg.Data,
	)
	return err
}
