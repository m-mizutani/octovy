package db

import (
	"context"
	"fmt"

	"github.com/m-mizutani/goerr"
	"github.com/m-mizutani/octovy/pkg/domain/model"
	"github.com/m-mizutani/octovy/pkg/infra/ent"
	"github.com/m-mizutani/octovy/pkg/infra/ent/repository"
	"github.com/m-mizutani/octovy/pkg/infra/ent/vulnerability"
	"github.com/m-mizutani/octovy/pkg/infra/ent/vulnstatusindex"
)

func (x *Client) PutVulnerabilities(ctx context.Context, vulnerabilities []*ent.Vulnerability) error {
	if x.lock {
		x.mutex.Lock()
		defer x.mutex.Unlock()
	}

	vulnBuilder := make([]*ent.VulnerabilityCreate, len(vulnerabilities))
	for i, vuln := range vulnerabilities {
		vulnBuilder[i] = x.client.Vulnerability.Create().
			SetID(vuln.ID).
			SetFirstSeenAt(vuln.FirstSeenAt).
			SetLastModifiedAt(vuln.LastModifiedAt).
			SetTitle(vuln.Title).
			SetDescription(vuln.Description).
			SetCweID(vuln.CweID).
			SetSeverity(vuln.Severity).
			SetCvss(vuln.Cvss).
			SetReferences(vuln.References)
	}

	q := x.client.Vulnerability.
		CreateBulk(vulnBuilder...).
		OnConflictColumns(vulnerability.FieldID).
		UpdateLastModifiedAt().
		UpdateTitle().
		UpdateDescription().
		UpdateCweID().
		UpdateSeverity().
		UpdateCvss().
		UpdateReferences()

	if err := q.Exec(ctx); err != nil {
		return goerr.Wrap(err)
	}

	return nil
}

func (x *Client) GetVulnerability(ctx context.Context, id string) (*ent.Vulnerability, error) {
	vuln, err := x.client.Vulnerability.Get(ctx, id)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, nil
		}
		return nil, goerr.Wrap(err).With("id", id)
	}
	return vuln, nil
}

func (x *Client) GetLatestVulnerabilities(ctx context.Context, offset int, limit int) ([]*ent.Vulnerability, error) {
	vulns, err := x.client.Vulnerability.Query().
		Order(ent.Desc(vulnerability.FieldFirstSeenAt)).
		Offset(offset).Limit(limit).All(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, nil
		}
		return nil, goerr.Wrap(err).With("offset", offset).With("limit", limit)
	}
	return vulns, nil
}

type vulnStatusIDKey struct {
	owner   string
	repo    string
	src     string
	pkgName string
	vulnID  string
}

func vulnStatusID(key *vulnStatusIDKey) string {
	return fmt.Sprintf("%s/%s|%s|%s|%s", key.owner, key.repo, key.src, key.pkgName, key.vulnID)
}

func (x *Client) PutVulnStatus(ctx context.Context, repo *ent.Repository, status *ent.VulnStatus, userID int) error {
	if x.lock {
		x.mutex.Lock()
		defer x.mutex.Unlock()
	}

	id := vulnStatusID(&vulnStatusIDKey{
		owner:   repo.Owner,
		repo:    repo.Name,
		src:     status.Source,
		pkgName: status.PkgName,
		vulnID:  status.VulnID,
	})

	added, err := x.client.VulnStatus.Create().
		SetStatus(status.Status).
		SetSource(status.Source).
		SetPkgName(status.PkgName).
		SetPkgType(status.PkgType).
		SetVulnID(status.VulnID).
		SetExpiresAt(status.ExpiresAt).
		SetCreatedAt(status.CreatedAt).
		SetComment(status.Comment).
		SetAuthorID(userID).
		Save(ctx)
	if err != nil {
		return goerr.Wrap(err)
	}

	if err := x.client.VulnStatusIndex.Create().SetID(id).AddStatus(added).OnConflictColumns("id").UpdateNewValues().Exec(ctx); err != nil {
		return goerr.Wrap(err)
	}

	n, err := repo.QueryStatus().Where(vulnstatusindex.ID(id)).Count(ctx)
	if err != nil {
		return goerr.Wrap(err)
	}

	if n == 0 {
		if _, err := repo.Update().AddStatuIDs(id).Save(ctx); err != nil {
			return goerr.Wrap(err)
		}
	}

	return nil
}

func (x *Client) GetVulnStatus(ctx context.Context, repo *model.GitHubRepo) ([]*ent.VulnStatus, error) {
	resp, err := x.client.Repository.Query().
		Where(repository.Owner(repo.Owner)).
		Where(repository.Name(repo.RepoName)).
		WithStatus(func(vsiq *ent.VulnStatusIndexQuery) {
			vsiq.WithStatus(func(vsq *ent.VulnStatusQuery) {
				vsq.Order(ent.Desc("created_at")).Limit(1)
			})
		}).
		First(ctx)
	if err != nil {
		return nil, goerr.Wrap(err)
	}
	if len(resp.Edges.Status) == 0 {
		return nil, nil
	}

	status := make([]*ent.VulnStatus, len(resp.Edges.Status))
	for i, idx := range resp.Edges.Status {
		status[i] = idx.Edges.Status[0]
	}

	return status, nil
}
