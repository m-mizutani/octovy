package db

import (
	"fmt"
	"time"

	"github.com/guregu/dynamo"
	"github.com/m-mizutani/goerr"
	"github.com/m-mizutani/octovy/pkg/domain/model"
)

const vulnerabilityTimeKey = "2006-01-02T15:04:05"

func vulnerabilityPK() string {
	return "list:vulnerability"
}
func vulnerabilitySK(vulnID string) string {
	return vulnID
}
func vulnerabilityPK2() string {
	return "list:vulnerability"
}
func vulnerabilitySK2(firstSeenAt int64, vulnID string) string {
	return fmt.Sprintf("%s/%s", time.Unix(firstSeenAt, 0).Format(vulnerabilityTimeKey), vulnID)
}

func (x *DynamoClient) InsertVulnerability(vuln *model.Vulnerability) error {
	// TODO: Check if record exists before put operation to use R/W capacity more efficiently
	record := &dynamoRecord{
		PK:  vulnerabilityPK(),
		SK:  vulnerabilitySK(vuln.VulnID),
		PK2: vulnerabilityPK2(),
		SK2: vulnerabilitySK2(vuln.FirstSeenAt, vuln.VulnID),
		Doc: vuln,
	}

	q := x.table.Put(record).If("attribute_not_exists(pk) AND attribute_not_exists(sk)")
	if err := q.Run(); err != nil {
		if !isConditionalCheckErr(err) {
			return goerr.Wrap(err).With("record", record)
		}

		// Record exists, then update vulnerability info
		update := x.table.Update("pk", record.PK).
			Range("sk", record.SK).
			Set("doc.'Detail'", vuln.Detail).
			Set("doc.'LastModifiedAt'", vuln.LastModifiedAt).
			If("doc.'LastModifiedAt' < ?", vuln.LastModifiedAt)

		if err := update.Run(); err != nil {
			if !isConditionalCheckErr(err) {
				return goerr.Wrap(err)
			}
		}
	}

	return nil
}

func (x *DynamoClient) FindVulnerability(vulnID string) (*model.Vulnerability, error) {
	var record *dynamoRecord
	pk := vulnerabilityPK()
	sk := vulnerabilitySK(vulnID)
	if err := x.table.Get("pk", pk).Range("sk", dynamo.Equal, sk).One(&record); err != nil {
		if !isNotFoundErr(err) {
			return nil, goerr.Wrap(err).With("pk", pk).With("sk", sk)
		}
		return nil, nil
	}

	var vuln model.Vulnerability
	if err := record.Unmarshal(&vuln); err != nil {
		return nil, err
	}

	return &vuln, nil
}

func (x *DynamoClient) FindLatestVulnerabilities(n int) ([]*model.Vulnerability, error) {
	var records []*dynamoRecord
	pk2 := vulnerabilityPK2()
	if err := x.table.Get("pk2", pk2).Index(dynamoGSIName2nd).Order(dynamo.Descending).Limit(int64(n)).All(&records); err != nil {
		if !isNotFoundErr(err) {
			return nil, goerr.Wrap(err)
		}
		return nil, nil
	}

	vulns := make([]*model.Vulnerability, len(records))
	for i := range records {
		if err := records[i].Unmarshal(&vulns[i]); err != nil {
			return nil, err
		}
	}

	return vulns, nil

}

func (x *DynamoClient) GetVulnerabilities(vulnIDs []string) ([]*model.Vulnerability, error) {
	if len(vulnIDs) == 0 {
		return nil, nil
	}

	var keys []dynamo.Keyed
	var records []*dynamoRecord

	for _, vulnID := range vulnIDs {
		keys = append(keys, &dynamoRecord{
			PK: vulnerabilityPK(),
			SK: vulnerabilitySK(vulnID),
		})
	}

	if err := x.table.Batch("pk", "sk").Get(keys...).All(&records); err != nil {
		// If no matched record, DynamoDB returns not found.
		if isNotFoundErr(err) {
			return nil, nil
		}
		return nil, goerr.Wrap(err).With("vulnIDs", vulnIDs)
	}

	results := make([]*model.Vulnerability, len(records))
	for i := range records {
		if err := records[i].Unmarshal(&results[i]); err != nil {
			return nil, err
		}
	}

	return results, nil
}
