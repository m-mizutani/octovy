package api

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/m-mizutani/octovy/pkg/domain/model"
	"github.com/m-mizutani/octovy/pkg/domain/types"
	"github.com/m-mizutani/octovy/pkg/infra/ent"
)

/*
func getVulnerability(c *gin.Context) {
	cfg := getConfig(c)
	vulnID := c.Param("vuln_id")

	vuln, err := cfg.Usecase.FindVulnerability(vulnID)
	if err != nil {
		_ = c.Error(err)
		return
	}

	c.JSON(http.StatusOK, baseResponse{Data: vuln})
}
*/
type postVulnStatusRequest struct {
	Status    types.VulnStatusType
	Source    string
	PkgType   types.PkgType
	PkgName   string
	VulnID    string
	ExpiresAt int64
	Comment   string
}

func postVulnStatus(c *gin.Context) {
	/*
		ssn, err := isAuthenticated(c)
		if err != nil {
			c.Error(goerr.Wrap(model.ErrAuthenticationFailed, "Login before updateing status"))
			return
		}
	*/
	uc := getUsecase(c)

	owner := c.Param("owner")
	repoName := c.Param("repo_name")

	var req postVulnStatusRequest
	if err := c.BindJSON(&req); err != nil {
		_ = c.Error(err)
		return
	}

	vulnStatus := &model.UpdateVulnStatusRequest{
		GitHubRepo: model.GitHubRepo{
			Owner:    owner,
			RepoName: repoName,
		},
		VulnStatus: ent.VulnStatus{
			Status:    req.Status,
			Source:    req.Source,
			PkgType:   req.PkgType,
			PkgName:   req.PkgName,
			VulnID:    req.VulnID,
			ExpiresAt: req.ExpiresAt,
			Comment:   req.Comment,
		},
		// UserID: ssn.Edges.Login.ID,
	}

	if err := uc.UpdateVulnStatus(c, vulnStatus); err != nil {
		_ = c.Error(err)
		return
	}

	c.JSON(http.StatusOK, baseResponse{Data: vulnStatus})
}
