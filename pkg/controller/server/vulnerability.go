package server

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/m-mizutani/goerr"
	"github.com/m-mizutani/octovy/pkg/domain/model"
)

func getVulnerability(c *gin.Context) {
	cfg := getConfig(c)
	vulnID := c.Param("vuln_id")

	vuln, err := cfg.Usecase.FindVulnerability(vulnID)
	if err != nil {
		_ = c.Error(err)
		return
	}

	c.JSON(http.StatusOK, baseResponse{Data: vuln})
}

type postVulnStatusRequest struct {
	Status    model.VulnStatusType
	Source    string
	PkgType   model.PkgType
	PkgName   string
	VulnID    string
	ExpiresAt int64
	Comment   string
}

func postVulnStatus(c *gin.Context) {
	ssn, err := isAuthenticated(c)
	if err != nil {
		c.Error(goerr.Wrap(model.ErrAuthenticationFailed, "Login before updateing status"))
		return
	}

	cfg := getConfig(c)

	owner := c.Param("owner")
	repoName := c.Param("repo_name")

	var req postVulnStatusRequest
	if err := c.BindJSON(&req); err != nil {
		_ = c.Error(err)
		return
	}

	vulnStatus := &model.VulnStatus{
		GitHubRepo: model.GitHubRepo{
			Owner:    owner,
			RepoName: repoName,
		},
		VulnPackageKey: model.VulnPackageKey{
			Source:  req.Source,
			PkgType: req.PkgType,
			PkgName: req.PkgName,
			VulnID:  req.VulnID,
		},
		Status:    req.Status,
		ExpiresAt: req.ExpiresAt,
		Comment:   req.Comment,
		UserID:    ssn.UserID,
	}

	if err := cfg.Usecase.UpdateVulnStatus(vulnStatus); err != nil {
		_ = c.Error(err)
		return
	}

	c.JSON(http.StatusOK, baseResponse{Data: vulnStatus})
}
