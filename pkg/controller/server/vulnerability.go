package server

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"

	"github.com/m-mizutani/goerr"
	"github.com/m-mizutani/octovy/pkg/domain/model"
	"github.com/m-mizutani/octovy/pkg/domain/types"
	"github.com/m-mizutani/octovy/pkg/infra/ent"
)

type respVulnerabilities struct {
	Vulnerabilities []*ent.Vulnerability `json:"vulnerabilities"`
	Total           int                  `json:"total"`
}

func getVulnerabilities(c *gin.Context) {
	uc := getUsecase(c)
	var limit, offset int64
	var err error

	if s := c.Query("limit"); s == "" {
		limit = 20
	} else {
		if limit, err = strconv.ParseInt(s, 10, 32); err != nil {
			c.Error(model.ErrInvalidInput.Wrap(err))
			return
		}
		if limit <= 0 {
			c.Error(goerr.Wrap(model.ErrInvalidInput, "limit must be greater than 0"))
			return
		}
	}

	// offset default is 0
	if s := c.Query("offset"); s != "" {
		if offset, err = strconv.ParseInt(s, 10, 32); err != nil {
			c.Error(model.ErrInvalidInput.Wrap(err))
			return
		}
		if offset < 0 {
			c.Error(goerr.Wrap(model.ErrInvalidInput, "offset must be equal or greater than 0"))
			return
		}
	}

	vulns, err := uc.GetVulnerabilities(c, offset, limit)
	if err != nil {
		_ = c.Error(err)
		return
	}
	count, err := uc.GetVulnerabilityCount(c)
	if err != nil {
		c.Error(err)
		return
	}

	c.JSON(http.StatusOK, baseResponse{Data: respVulnerabilities{
		Vulnerabilities: vulns,
		Total:           count,
	}})
}

func getVulnerability(c *gin.Context) {
	uc := getUsecase(c)

	vulnID := c.Param("vuln_id")

	resp, err := uc.GetVulnerability(c, vulnID)
	if err != nil {
		c.Error(err)
		return
	}
	if resp == nil {
		c.Error(goerr.Wrap(model.ErrVulnerabilityNotFound))
		return
	}

	c.JSON(http.StatusOK, baseResponse{Data: resp})
}

type postVulnStatusRequest struct {
	Status    types.VulnStatusType
	Source    string
	PkgType   string
	PkgName   string
	VulnID    string
	ExpiresAt int64
	Comment   string
}

func postVulnStatus(c *gin.Context) {
	uc := getUsecase(c)
	ssn := getSession(c)
	if ssn == nil {
		errResp(c, http.StatusUnauthorized, model.ErrAuthenticationFailed)
		return
	}

	owner := c.Param("owner")
	repoName := c.Param("repo_name")

	var req postVulnStatusRequest
	if err := c.BindJSON(&req); err != nil {
		_ = c.Error(err)
		return
	}

	vulnStatus := &model.UpdateVulnStatusRequest{
		GitHubRepo: model.GitHubRepo{
			Owner:    owner,
			RepoName: repoName,
		},
		VulnStatus: ent.VulnStatus{
			Status:    req.Status,
			Source:    req.Source,
			PkgType:   req.PkgType,
			PkgName:   req.PkgName,
			VulnID:    req.VulnID,
			ExpiresAt: req.ExpiresAt,
			Comment:   req.Comment,
		},
		UserID: ssn.UserID,
	}

	if err := uc.UpdateVulnStatus(c, vulnStatus); err != nil {
		_ = c.Error(err)
		return
	}

	c.JSON(http.StatusOK, baseResponse{Data: vulnStatus})
}
